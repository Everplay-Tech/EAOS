# Implementation + Design Guide (for isolated execution)
Timestamp: 2025-12-29 14:29:03

## Purpose
Provide a clear, end-to-end implementation guide for building the Eä OS vision: a muscle-based OS with fixed-size secure blobs, strong cryptography, modular execution units, and a safe embedded small LLM. This guide is structured so another instance can execute independently without needing additional context.

## Problem Definition (as of now)
We have a repo that conceptually describes a muscle-based OS (sealed fixed-size blobs, referee loader, nucleus kernel, ledger, symbiote). The primary blockers are compile/test health and API drift in transport and muscle organelles. We need:
- A stable, reproducible blob contract and crypto primitives.
- A functioning toolchain that produces valid blobs.
- A loader that verifies and loads blobs reliably.
- A ledger + transport layer that compiles and supports append/read/subscribe.
- Optional organelles for WASM and LLMs that compile and can be integrated later.

## Core Design Principles
1) **Fixed-size contract**: Enforce a constant blob size and manifest, minimal parser surface. Zero heap allocation in the trusted loader.
2) **Capability confinement**: Capabilities must be declared in the manifest and enforced by loader/runtime.
3) **Deterministic, testable crypto**: Deterministic test vectors are allowed, production uses random nonces.
4) **Modularity**: Every muscle is a sealed, replaceable unit. Change protocols, not runtime behavior.
5) **Minimal TCB**: Referee + loader + contract parsing remain small and verifiable.
6) **Pragmatic roadmap**: Clear, auditable steps from “builds” -> “tests” -> “proto deployment”.

## Target Architecture (high-level)
- **Muscle Contract v6**: ChaCha20-Poly1305, 24-byte nonce field, 8256B blob, 256B manifest, 8192B payload.
- **Muscle Compiler**: Produces blobs, sets manifest with code hash, aligns with contract v6.
- **Referee Loader**: Validates header/manifest, decrypts, verifies code hash, loads code.
- **Nucleus**: Minimal kernel executing muscle rules with capability-based syscalls.
- **Ledger**: Append-only lattice ledger for global state and updates.
- **Symbiote**: Automated policy agent for patching/quarantine events.

## Execution Plan (ordered, risk-aware)

### Phase 0: Contract + Crypto Alignment (DONE)
- Confirm `docs/muscle-contract-v6.md` matches implementation.
- Ensure compiler + referee use the same contract constants and key derivation.
- Keep 24-byte nonce field to allow future XChaCha without changing blob layout.

### Phase 1: Build/Compile Health (Priority)
Goal: reach a “green core” where the toolchain compiles and core tests pass.

1) **Ledger transport compile fixes** (highest block)
   - Update dependencies in `ledger/transport/Cargo.toml`:
     - Add `http = "0.2"`.
     - Add `tokio-stream = { version = "0.1", features = ["sync"] }`.
     - Keep `rustls` and `quinn` versions in sync with code (or update code to API changes).
   - Update rustls 0.23 API usage:
     - Replace `Certificate`/`PrivateKey` with `rustls::pki_types::{CertificateDer, PrivateKeyDer, PrivatePkcs8KeyDer, ServerName, UnixTime}`.
     - Replace `with_safe_defaults` with the new builder chain (no defaults helper).
     - Implement `ServerCertVerifier` with new method signatures.
   - Update quinn API usage:
     - `Endpoint::server` returns `Endpoint` only; use `endpoint.accept()` to handle incoming.
   - Fix tokio UnixStream cloning:
     - Replace `try_clone` with `into_split` or clone the fd using std `UnixStream` conversion.
   - Implement `tonic::transport::server::Connected` for `QuicGrpcStream`.

2) **muscle-ea-pathfinder compile fixes** (next block)
   - Add missing dependencies: `hmac` and `bytemuck`.
   - Resolve `#![forbid(unsafe_code)]` conflicts:
     - Either remove unsafe usage or move it into a safe bytemuck conversion.
   - Update wasmtime APIs:
     - `FuelExhausted` changed; update trap handling.
     - `guard_before_linear_mem` -> `guard_before_linear_memory`.
   - Fix `Trap::from` usage to new error types.
   - Fix `RngCore` clone expectations (remove `try_clone` or implement alternative).

3) **ea-symbiote integration test fix**
   - Replace borrow of `blake3::hash(...).as_bytes()` with a named binding.

4) **Docs alignment**
   - Update `ARCHITECTURE.md` and `architectureandmore.md` to match v6 crypto.
   - Updated `docs/muscle-contract-v6.md` tag line to ChaCha20-Poly1305.

### Phase 2: Loader/Kernel Integrity
- Validate referee loader using the v6 contract and ensure header/manifest parity.
- Removed `referee/src/crypto.rs` (legacy v5); loader uses `muscle-contract`.
- Confirm nucleus compile and enforce `PAYLOAD_LEN - MANIFEST_LEN` sizing.

### Phase 3: Runtime + LLM Integration
- Introduce LLM profile structure (already optional in manifest). Keep LLM support off by default.
- Plan for a small LLM (phi2-class) running in a muscle or separate organelle.
- Define “LLM wall”: LLM can only read certain lattice channels and emit updates via declared capabilities.

### Phase 4: Hardware / VM Path (Mac + ARM64)
- Prefer AArch64 + UEFI. Validate using QEMU virt on macOS.
- Ensure the pipeline can target Raspberry Pi 5 (ARM64). This keeps the path open for custom hardware.

## Concrete Fix Plan for Ledger Transport (detailed)
1) **Cargo.toml changes**:
   - Add `http = "0.2"`.
   - Add `tokio-stream = { version = "0.1", features = ["sync"] }`.
2) **Rustls 0.23 updates**:
   - Use `rustls::pki_types::{CertificateDer, PrivateKeyDer, PrivatePkcs8KeyDer, ServerName, UnixTime}`.
   - Use `rustls::ClientConfig::builder().with_root_certificates(...).with_no_client_auth()`.
   - Create a custom verifier implementing new trait methods.
3) **Rcgen changes**:
   - Use `generate_simple_self_signed` to produce `CertifiedKey { cert, key_pair }`.
   - Use `cert.der().to_vec()` for `CertificateDer`.
   - Use `PrivateKeyDer::from(PrivatePkcs8KeyDer::from(key_pair.serialize_der()))`.
4) **Quinn updates**:
   - Replace `Endpoint::server(...)` tuple usage with:
     - `let endpoint = Endpoint::server(...)?;`
     - `let mut incoming = endpoint.accept();`
5) **Tonic Connected**:
   - Implement `tonic::transport::server::Connected` for `QuicGrpcStream` with `ConnectInfo = ()`.

## Concrete Fix Plan for Pathfinder (detailed)
- Add deps: `hmac`, `bytemuck`.
- Replace unsafe header reads with safe deserialization.
- Update wasmtime APIs and trap handling for v24.
- Remove or allow unsafe if required (choose one approach and document).

## Quality Gates (non-negotiable)
- `cargo test -p muscle-contract -p muscle-compiler` must pass.
- Ledger stack should compile and run basic append/read/subscribe tests.
- Pathfinder + neurowasm + axon + dendrite compile after API updates.
- Keep contract constants and docs in sync.

## Minimal Acceptance Criteria
- Toolchain produces a valid 8256-byte blob.
- Loader can open and verify blob using v6 contract.
- Ledger transport runs at least one in-VM or Unix IPC end-to-end test.
- Tests pass or are explicitly documented as blocked.

## Testing Strategy
1) Start with unit tests for compiler/contract.
2) Build ledger-transport and run ledger tests (excluding networked transport first).
3) Add targeted tests for QUIC/gRPC only after basic compile success.
4) Validate loader on QEMU/UEFI (if possible on host).

## Open Questions / Follow-ups
- Should QUIC/gRPC remain enabled by default or be feature-gated until stable?
- Should pathfinder’s WASM host be no_std or std-only (wasmtime implies std)?
- Does preloader truly need to be 2KiB, or do we split it into a 2KiB loader + external blob pointer?

## Output format for the isolated instance
- Maintain a new timestamped note per change.
- Keep all changes minimal and well-scoped.
- Only fix the highest-priority blockers first, then re-run tests.
