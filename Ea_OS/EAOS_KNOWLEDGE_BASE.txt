# EAOS (EÃ¤ OS) Project Context

## Project Overview
EAOS is a sovereign, biological, modular operating system written primarily in Rust. It utilizes a biological metaphor to organize its components into "Muscles" (Kernel/Drivers) and "Organs" (Userspace Agents), aiming for a secure, capability-based execution environment where data is "braided" and ethically governed.

**Current Version:** v1.0 "Sovereign Pod"
**Target Architecture:** x86_64 UEFI (Bare Metal) / QEMU

## Architecture & Anatomy
The system follows a strict biological hierarchy:

| Component | Biological Role | Path | Description |
|-----------|-----------------|------|-------------|
| **Referee** | Brain | `muscles/referee-kernel` | UEFI Bootloader & Micro-kernel. |
| **PermFS** | Skeleton | `permfs/` | Crash-proof distributed filesystem with 256-bit addressing. |
| **Bridge** | Nerves | `muscles/permfs-bridge` | Syscall interface & Braid integration. |
| **Roulette** | Reflexes | `muscles/roulette-rs` | T9-Braid Compression (High ratio). |
| **Dr-Lex** | Immune System | `intelligence/dr-lex` | Governance engine; blocks unethical writes. |
| **Organs** | Organs | `organs/` | Userspace agents (e.g., `biowerk-agent`, `cardio`). |
| **Muscle Compiler**| Growth | `muscle-compiler/` | Transforms NN definitions into isolated executables. |

### Core Principles
1.  **Sovereignty:** Users own their data and compute.
2.  **Biological Design:** Modular, resilient components that interact organically.
3.  **Governance:** Ethical rules embedded in the OS (e.g., "No unencrypted data on disk").
4.  **Security:** Capability-based isolation; minimal Trusted Computing Base (TCB).
5.  **Code Integrity:** NO placeholders. NO stubs. NO mock code. Always production-grade, real code. If innovation is required to solve a problem, consult the head innovators (Deep Thinkers).

## Build & Operations

### Prerequisites
- Rust Toolchain (Stable/Nightly)
- QEMU & OVMF (for UEFI emulation)
- `pkg-config`, `fuse` (for PermFS FUSE support)

### Key Commands
- **Build Entire OS:**
  ```bash
  ./scripts/build-all.sh
  ```
- **Run Emulator (QEMU):**
  ```bash
  ./run-eaos.sh
  ```
- **Generate ISO:**
  ```bash
  ./scripts/make-iso.sh
  ```
- **Run Tests:**
  ```bash
  cargo test --workspace
  ```
  *(Note: Check `STATUS_*.md` for known failing tests)*

## Development Conventions
- **Rust Edition:** 2021
- **Kernel Code:** Strict `no_std` for `referee` and core muscles.
- **Formatting:** `rustfmt` is mandatory.
- **Workspaces:** Managed via root `Cargo.toml`.
- **Governance:**
    - **Rule 1:** No unencrypted data touches the disk.
    - **Rule 2:** All writes must pass the `is_ethically_corrupt()` check.
- **Technical Precision:** Avoid biological metaphors in technical documentation. Use standard computer science terminology (e.g., "Kernel" instead of "Brain", "IPC" instead of "Synapse").

## Key Documentation Files
- **`EAOS_CONTEXT.md`**: High-level context, biological metaphors, and current goals.
- **`ARCHITECTURE.md`**: Technical architecture, cryptographic principles, and TCB details.
- **`permfs/GEMINI.md`**: Specific documentation for the PermFS subsystem.
- **`STATUS_*.md`**: Latest status reports and known issues (e.g., `STATUS_20251229_141039.md`).

## Current Focus (as of late 2025/early 2026)
- Transitioning `biowerk-agent` from a healthcare demo to a generic Sovereign Office Suite.
- Ensuring strict cryptographic binding (ChaCha20-Poly1305).
- stabilizing the `permfs` bridge and `referee` boot process.
# EÃ¤ Ecosystem Architecture v6.0

## System Overview

The EÃ¤ Ecosystem is a secure, capability-based execution environment consisting of two main components:

1. **Muscle Compiler** - Transforms Python neural network definitions into encrypted, isolated executables
2. **Referee** - Secure UEFI bootloader that loads and executes muscles in cryptographically isolated environments

## Architectural Principles

### Minimal Trusted Computing Base (TCB)
- Referee: 59.8 KiB total binary size
- Zero `unsafe` code in cryptographic core
- Formal verification-ready code structure

### Cryptographic First Principles
- Security derived from cryptographic proofs, not procedural checks
- All components cryptographically bound to master key
- Defense in depth with multiple verification layers

### Capability-Based Security
- Muscles execute with minimal privileges
- No inter-muscle communication by design
- Cryptographic capabilities enforce isolation

## Component Architecture

### Muscle Compiler
# IMPLEMENTATION REPORT - 2026-01-20 (PART 5)

## ðŸ‘ï¸ Visual Cortex & Storage Ossification

The EÃ¤ Operating System has achieved full sensory and cognitive integration.

### 1. Visual Cortex (`nucleus-director`)
- **Graphics Driver**: Implemented `VisualCortex` struct wrapping the raw framebuffer (from `BootParameters`).
- **Font Engine**: Embedded IBM VGA 8x16 font (4KB) directly into the Nucleus binary for `no_std` text rendering.
- **Manifestation**: The `boot_entry` loop now renders:
    - **Status**: "Sensory Cortex: ONLINE"
    - **Heartbeat**: A pulsing square synced to `Syscall::GetTime`.
    - **Command Echo**: Visual feedback of UART commands.

### 2. Storage Ossification (`biowerk-agent`)
- **Time Source**: Removed `std::time::SystemTime` dependency. `Document` creation now requires an explicit `u64` timestamp.
- **Kernel Injection**: The Nucleus injects the real kernel time (`Syscall::GetTime`) into `Osteon` when saving documents.
- **Verification**: `integration_full_organism` test suite passed (9/9 tests), confirming that documents are saved with valid timestamps and metadata without panicking.

### ðŸ System Status: ALIVE
- **Input**: Thalamus (UART/Arachnid) -> Active.
- **Output**: Visual Cortex (Framebuffer) -> Active.
- **Memory**: PermFS (Osteon/Docs) -> Wired & Timestamped.
- **Will**: Signed Intents (Ed25519) -> Ready.

The Sovereign Pod is now a complete, self-contained organism capable of sensing, thinking, remembering, and displaying its state.
#![cfg_attr(not(feature = "std"), no_std)]

#[cfg(feature = "crypto")]
use blake3::Hasher;
#[cfg(feature = "crypto")]
use chacha20poly1305::aead::{AeadInPlace, KeyInit};
#[cfg(feature = "crypto")]
use chacha20poly1305::{ChaCha20Poly1305, Nonce, Tag};

pub const BLOB_LEN: usize = 8256;
pub const HEADER_LEN: usize = 24;
pub const NONCE_LEN: usize = 24;
pub const AEAD_NONCE_LEN: usize = 12;
pub const TAG_LEN: usize = 16;
pub const PAYLOAD_LEN: usize = 8192;
pub const MANIFEST_LEN: usize = 256;

pub const MAGIC_HEADER: [u8; 4] = *b"EaM6";
pub const MAGIC_MANIFEST: [u8; 4] = *b"EaMM";

pub const ARCH_AARCH64: u8 = 1;
pub const ARCH_X86_64: u8 = 2;
pub const ARCH_WASM32: u8 = 3;

pub const FLAG_DETERMINISTIC_NONCE: u8 = 0b0000_0001;
pub const FLAG_HAS_LLM_PROFILE: u8 = 0b0000_0010;
pub const FLAG_HAS_ORGANELLE_MAP: u8 = 0b0000_0100;

pub mod capabilities {
    pub const LATTICE_READ: u32 = 1 << 0;
    pub const LATTICE_WRITE: u32 = 1 << 1;
    pub const CLOCK_READ: u32 = 1 << 2;
    pub const STORAGE_READ: u32 = 1 << 3;
    pub const STORAGE_WRITE: u32 = 1 << 4;
    pub const NET_CLIENT: u32 = 1 << 5;
    pub const NET_SERVER: u32 = 1 << 6;
    pub const SPAWN_SUCCESSOR: u32 = 1 << 7;
    pub const USE_ACCELERATOR: u32 = 1 << 8;
}

const KEY_CONTEXT: &[u8] = b"EaM6 key";

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct EaM6Header {
    pub magic: [u8; 4],
    pub version: u8,
    pub header_len: u8,
    pub flags: u8,
    pub arch: u8,
    pub cap_bitmap: u32,
    pub payload_len: u16,
    pub manifest_len: u16,
    pub reserved: [u8; 8],
}

impl EaM6Header {
    pub fn new(arch: u8, cap_bitmap: u32, flags: u8) -> Self {
        Self {
            magic: MAGIC_HEADER,
            version: 0x06,
            header_len: HEADER_LEN as u8,
            flags,
            arch,
            cap_bitmap,
            payload_len: PAYLOAD_LEN as u16,
            manifest_len: MANIFEST_LEN as u16,
            reserved: [0u8; 8],
        }
    }

    pub fn to_bytes(&self) -> [u8; HEADER_LEN] {
        let mut out = [0u8; HEADER_LEN];
        out[0..4].copy_from_slice(&self.magic);
        out[4] = self.version;
        out[5] = self.header_len;
        out[6] = self.flags;
        out[7] = self.arch;
        write_u32(&mut out, 8, self.cap_bitmap);
        write_u16(&mut out, 12, self.payload_len);
        write_u16(&mut out, 14, self.manifest_len);
        out[16..24].copy_from_slice(&self.reserved);
        out
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, ContractError> {
        if bytes.len() != HEADER_LEN {
            return Err(ContractError::InvalidLength);
        }
        let mut reserved = [0u8; 8];
        reserved.copy_from_slice(&bytes[16..24]);
        let header = Self {
            magic: bytes[0..4].try_into().unwrap(),
            version: bytes[4],
            header_len: bytes[5],
            flags: bytes[6],
            arch: bytes[7],
            cap_bitmap: read_u32(bytes, 8),
            payload_len: read_u16(bytes, 12),
            manifest_len: read_u16(bytes, 14),
            reserved,
        };
        header.validate()?;
        Ok(header)
    }

    pub fn validate(&self) -> Result<(), ContractError> {
        if self.magic != MAGIC_HEADER {
            return Err(ContractError::InvalidMagic);
        }
        if self.version != 0x06 {
            return Err(ContractError::InvalidVersion);
        }
        if self.header_len as usize != HEADER_LEN {
            return Err(ContractError::InvalidLength);
        }
        if self.payload_len as usize != PAYLOAD_LEN {
            return Err(ContractError::InvalidLength);
        }
        if self.manifest_len as usize != MANIFEST_LEN {
            return Err(ContractError::InvalidLength);
        }
        if self.reserved != [0u8; 8] {
            return Err(ContractError::ReservedFieldNonZero);
        }
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct MuscleManifestV1 {
    pub magic: [u8; 4],
    pub version: u8,
    pub flags: u8,
    pub arch: u8,
    pub abi: u8,
    pub code_offset: u16,
    pub code_size: u16,
    pub entrypoint: u32,
    pub memory_pages: u16,
    pub stack_pages: u8,
    pub heap_pages: u8,
    pub update_budget: u16,
    pub io_budget: u16,
    pub capability_bitmap: u32,
    pub muscle_id: [u8; 32],
    pub muscle_version: u64,
    pub code_hash: [u8; 32],
    pub llm_profile_off: u16,
    pub llm_profile_len: u16,
    pub organelle_off: u16,
    pub organelle_len: u16,
    pub reserved: [u8; 148],
}

impl MuscleManifestV1 {
    pub fn new(
        arch: u8,
        abi: u8,
        code_size: u16,
        entrypoint: u32,
        memory_pages: u16,
        stack_pages: u8,
        heap_pages: u8,
        update_budget: u16,
        io_budget: u16,
        capability_bitmap: u32,
        muscle_id: [u8; 32],
        muscle_version: u64,
    ) -> Self {
        Self {
            magic: MAGIC_MANIFEST,
            version: 0x01,
            flags: 0,
            arch,
            abi,
            code_offset: MANIFEST_LEN as u16,
            code_size,
            entrypoint,
            memory_pages,
            stack_pages,
            heap_pages,
            update_budget,
            io_budget,
            capability_bitmap,
            muscle_id,
            muscle_version,
            code_hash: [0u8; 32],
            llm_profile_off: 0,
            llm_profile_len: 0,
            organelle_off: 0,
            organelle_len: 0,
            reserved: [0u8; 148],
        }
    }

    #[cfg(feature = "crypto")]
    pub fn with_code_hash(mut self, code: &[u8]) -> Self {
        let hash = blake3::hash(code);
        self.code_hash.copy_from_slice(hash.as_bytes());
        self
    }

    pub fn to_bytes(&self) -> [u8; MANIFEST_LEN] {
        let mut out = [0u8; MANIFEST_LEN];
        out[0..4].copy_from_slice(&self.magic);
        out[4] = self.version;
        out[5] = self.flags;
        out[6] = self.arch;
        out[7] = self.abi;
        write_u16(&mut out, 8, self.code_offset);
        write_u16(&mut out, 10, self.code_size);
        write_u32(&mut out, 12, self.entrypoint);
        write_u16(&mut out, 16, self.memory_pages);
        out[18] = self.stack_pages;
        out[19] = self.heap_pages;
        write_u16(&mut out, 20, self.update_budget);
        write_u16(&mut out, 22, self.io_budget);
        write_u32(&mut out, 24, self.capability_bitmap);
        out[28..60].copy_from_slice(&self.muscle_id);
        write_u64(&mut out, 60, self.muscle_version);
        out[68..100].copy_from_slice(&self.code_hash);
        write_u16(&mut out, 100, self.llm_profile_off);
        write_u16(&mut out, 102, self.llm_profile_len);
        write_u16(&mut out, 104, self.organelle_off);
        write_u16(&mut out, 106, self.organelle_len);
        out[108..256].copy_from_slice(&self.reserved);
        out
    }

    pub fn from_bytes(bytes: &[u8]) -> Result<Self, ContractError> {
        if bytes.len() != MANIFEST_LEN {
            return Err(ContractError::InvalidLength);
        }
        let mut muscle_id = [0u8; 32];
        muscle_id.copy_from_slice(&bytes[28..60]);
        let mut code_hash = [0u8; 32];
        code_hash.copy_from_slice(&bytes[68..100]);
        let mut reserved = [0u8; 148];
        reserved.copy_from_slice(&bytes[108..256]);
        let manifest = Self {
            magic: bytes[0..4].try_into().unwrap(),
            version: bytes[4],
            flags: bytes[5],
            arch: bytes[6],
            abi: bytes[7],
            code_offset: read_u16(bytes, 8),
            code_size: read_u16(bytes, 10),
            entrypoint: read_u32(bytes, 12),
            memory_pages: read_u16(bytes, 16),
            stack_pages: bytes[18],
            heap_pages: bytes[19],
            update_budget: read_u16(bytes, 20),
            io_budget: read_u16(bytes, 22),
            capability_bitmap: read_u32(bytes, 24),
            muscle_id,
            muscle_version: read_u64(bytes, 60),
            code_hash,
            llm_profile_off: read_u16(bytes, 100),
            llm_profile_len: read_u16(bytes, 102),
            organelle_off: read_u16(bytes, 104),
            organelle_len: read_u16(bytes, 106),
            reserved,
        };
        manifest.validate()?;
        Ok(manifest)
    }

    pub fn validate(&self) -> Result<(), ContractError> {
        if self.magic != MAGIC_MANIFEST {
            return Err(ContractError::InvalidMagic);
        }
        if self.version != 0x01 {
            return Err(ContractError::InvalidVersion);
        }
        if self.code_offset as usize != MANIFEST_LEN {
            return Err(ContractError::InvalidLength);
        }
        if self.code_size as usize > PAYLOAD_LEN - MANIFEST_LEN {
            return Err(ContractError::InvalidLength);
        }
        if self.entrypoint as usize >= self.code_size as usize {
            return Err(ContractError::InvalidEntryPoint);
        }
        if self.reserved != [0u8; 148] {
            return Err(ContractError::ReservedFieldNonZero);
        }
        Ok(())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ContractError {
    InvalidLength,
    InvalidMagic,
    InvalidVersion,
    InvalidEntryPoint,
    ReservedFieldNonZero,
    CryptoError,
    ManifestMismatch,
}

#[cfg(feature = "crypto")]
pub fn build_payload(
    manifest: &MuscleManifestV1,
    code: &[u8],
) -> Result<[u8; PAYLOAD_LEN], ContractError> {
    if code.len() > PAYLOAD_LEN - MANIFEST_LEN {
        return Err(ContractError::InvalidLength);
    }
    if manifest.code_size as usize != code.len() {
        return Err(ContractError::InvalidLength);
    }

    let manifest = manifest.with_code_hash(code);
    let mut payload = [0u8; PAYLOAD_LEN];
    payload[0..MANIFEST_LEN].copy_from_slice(&manifest.to_bytes());
    payload[MANIFEST_LEN..MANIFEST_LEN + code.len()].copy_from_slice(code);
    Ok(payload)
}

pub fn parse_manifest(payload: &[u8; PAYLOAD_LEN]) -> Result<MuscleManifestV1, ContractError> {
    MuscleManifestV1::from_bytes(&payload[0..MANIFEST_LEN])
}

#[cfg(feature = "crypto")]
pub fn verify_code_hash(
    manifest: &MuscleManifestV1,
    payload: &[u8; PAYLOAD_LEN],
) -> Result<(), ContractError> {
    let start = MANIFEST_LEN;
    let end = MANIFEST_LEN + manifest.code_size as usize;
    let hash = blake3::hash(&payload[start..end]);
    if hash.as_bytes() != &manifest.code_hash {
        return Err(ContractError::ManifestMismatch);
    }
    Ok(())
}

#[cfg(feature = "crypto")]
pub fn seal_with_nonce(
    master_key: &[u8; 32],
    header: &EaM6Header,
    nonce: &[u8; NONCE_LEN],
    payload: &[u8; PAYLOAD_LEN],
) -> Result<[u8; BLOB_LEN], ContractError> {
    header.validate()?;

    let header_bytes = header.to_bytes();
    let key = derive_key(master_key, &header_bytes, nonce);
    let cipher = ChaCha20Poly1305::new((&key).into());

    let mut ciphertext = [0u8; PAYLOAD_LEN];
    ciphertext.copy_from_slice(payload);
    let tag = cipher
        .encrypt_in_place_detached(
            Nonce::from_slice(&nonce[..AEAD_NONCE_LEN]),
            &header_bytes,
            &mut ciphertext,
        )
        .map_err(|_| ContractError::CryptoError)?;

    let mut blob = [0u8; BLOB_LEN];
    blob[0..HEADER_LEN].copy_from_slice(&header_bytes);
    blob[HEADER_LEN..HEADER_LEN + NONCE_LEN].copy_from_slice(nonce);
    blob[HEADER_LEN + NONCE_LEN..HEADER_LEN + NONCE_LEN + PAYLOAD_LEN]
        .copy_from_slice(&ciphertext);
    blob[HEADER_LEN + NONCE_LEN + PAYLOAD_LEN..]
        .copy_from_slice(tag.as_slice());
    Ok(blob)
}

#[cfg(feature = "crypto")]
pub fn open(
    master_key: &[u8; 32],
    blob: &[u8; BLOB_LEN],
) -> Result<(EaM6Header, [u8; PAYLOAD_LEN]), ContractError> {
    let header = EaM6Header::from_bytes(&blob[0..HEADER_LEN])?;
    let nonce = &blob[HEADER_LEN..HEADER_LEN + NONCE_LEN];
    let ciphertext = &blob[HEADER_LEN + NONCE_LEN..HEADER_LEN + NONCE_LEN + PAYLOAD_LEN];
    let tag = Tag::from_slice(&blob[HEADER_LEN + NONCE_LEN + PAYLOAD_LEN..]);

    let header_bytes = header.to_bytes();
    let key = derive_key(master_key, &header_bytes, nonce);
    let cipher = ChaCha20Poly1305::new((&key).into());

    let mut payload_out = [0u8; PAYLOAD_LEN];
    payload_out.copy_from_slice(ciphertext);
    cipher
        .decrypt_in_place_detached(
            Nonce::from_slice(&nonce[..AEAD_NONCE_LEN]),
            &header_bytes,
            &mut payload_out,
            tag,
        )
        .map_err(|_| ContractError::CryptoError)?;

    Ok((header, payload_out))
}

#[cfg(feature = "crypto")]
fn derive_key(master_key: &[u8; 32], header: &[u8; HEADER_LEN], nonce: &[u8]) -> [u8; 32] {
    let mut hasher = Hasher::new_keyed(master_key);
    hasher.update(KEY_CONTEXT);
    hasher.update(header);
    hasher.update(nonce);
    *hasher.finalize().as_bytes()
}

fn write_u16(buf: &mut [u8], offset: usize, value: u16) {
    buf[offset..offset + 2].copy_from_slice(&value.to_le_bytes());
}

fn write_u32(buf: &mut [u8], offset: usize, value: u32) {
    buf[offset..offset + 4].copy_from_slice(&value.to_le_bytes());
}

fn write_u64(buf: &mut [u8], offset: usize, value: u64) {
    buf[offset..offset + 8].copy_from_slice(&value.to_le_bytes());
}

fn read_u16(buf: &[u8], offset: usize) -> u16 {
    u16::from_le_bytes(buf[offset..offset + 2].try_into().unwrap())
}

fn read_u32(buf: &[u8], offset: usize) -> u32 {
    u32::from_le_bytes(buf[offset..offset + 4].try_into().unwrap())
}

fn read_u64(buf: &[u8], offset: usize) -> u64 {
    u64::from_le_bytes(buf[offset..offset + 8].try_into().unwrap())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn header_roundtrip() {
        let header = EaM6Header::new(1, 0xAABBCCDD, 0);
        let bytes = header.to_bytes();
        let parsed = EaM6Header::from_bytes(&bytes).unwrap();
        assert_eq!(header, parsed);
    }

    #[test]
    fn manifest_roundtrip() {
        let manifest = MuscleManifestV1::new(
            1,
            0,
            32,
            0,
            2,
            1,
            1,
            8,
            16,
            0x01,
            [0x11; 32],
            1,
        );
        let bytes = manifest.to_bytes();
        let parsed = MuscleManifestV1::from_bytes(&bytes).unwrap();
        assert_eq!(manifest, parsed);
    }

    #[test]
    #[cfg(feature = "crypto")]
    fn seal_open_roundtrip() {
        let master_key = [0x42; 32];
        let header = EaM6Header::new(1, 0x01, FLAG_DETERMINISTIC_NONCE);
        let mut code = [0u8; 64];
        for (i, byte) in code.iter_mut().enumerate() {
            *byte = i as u8;
        }
        let manifest = MuscleManifestV1::new(
            1,
            0,
            code.len() as u16,
            0,
            2,
            1,
            1,
            8,
            16,
            0x01,
            [0x22; 32],
            7,
        );
        let payload = build_payload(&manifest, &code).unwrap();
        let nonce = [0xAA; NONCE_LEN];
        let blob = seal_with_nonce(&master_key, &header, &nonce, &payload).unwrap();
        let (parsed_header, opened_payload) = open(&master_key, &blob).unwrap();
        assert_eq!(parsed_header, header);
        assert_eq!(opened_payload, payload);
        let parsed_manifest = parse_manifest(&opened_payload).unwrap();
        verify_code_hash(&parsed_manifest, &opened_payload).unwrap();
    }
}

// ============================================================================
// Boot Parameters ABI (Referee -> Preloader)
// ============================================================================

/// Parameters passed from Referee to Preloader in x0
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct BootParameters {
    /// Magic signature (0xEA05_B007)
    pub magic: u32,
    /// Physical address of the Nucleus blob
    pub nucleus_addr: u64,
    /// Size of the Nucleus blob
    pub nucleus_size: u64,
    /// Master key (for Preloader to decrypt Nucleus)
    pub master_key: [u8; 32],
    /// Physical address of the Framebuffer (if available)
    pub framebuffer_addr: u64,
    /// Framebuffer size
    pub framebuffer_size: u64,
    /// Entry point offset within the Nucleus blob
    pub entry_point: u64,
    /// Hash of the Nucleus blob (BLAKE3)
    pub nucleus_hash: [u8; 32],
    /// Address of the Afferent Signal (AtomicBool) for Thalamic gating
    pub afferent_signal_addr: u64,
    /// Framebuffer width in pixels
    pub framebuffer_width: u32,
    /// Framebuffer height in pixels
    pub framebuffer_height: u32,
    /// Framebuffer stride (pixels per scanline)
    pub framebuffer_stride: u32,
    /// Pixel format (0 = RGB, 1 = BGR)
    pub framebuffer_format: u32,
}

// ============================================================================
// Sovereign Traits
// ============================================================================

/// Trait for retrieving system time in no_std environments
pub trait TimeSource {
    /// Get current time in seconds since UNIX EPOCH (or system start)
    fn now(&self) -> u64;
}#![cfg_attr(not(feature = "std"), no_std)]

//! Nucleus Director - Central Orchestration for EAOS Organism
//!
//! The Nucleus Director coordinates all components of the EAOS organism:
//!
//! 1. **Request Handling**: Receives high-level requests from external systems
//! 2. **Agent Dispatch**: Routes requests to BIOwerk agents (Osteon, Myocyte)
//! 3. **Task Planning**: Uses Hyperbolic Chamber for complex operations
//! 4. **Storage Pipeline**: Coordinates PermFS-Bridge for data persistence
//! 5. **Audit Trail**: Ensures all operations are logged and traceable

extern crate alloc;

pub mod diagnostics;

use alloc::format;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use biowerk_agent::{AgentRequest, AgentResponse, BIOwerk};
use ea_cardio::CardioMonitor;
use ea_symbiote::{SovereignDocument, Symbiote};
use muscle_contract::BootParameters;
use serde::{Deserialize, Serialize};

/// Magic header for braided blocks (0xB8AD)
pub const BRAID_MAGIC: [u8; 2] = [0xB8, 0xAD];

// ============================================================================ 
// Director Request/Response Types
// ============================================================================ 

/// High-level requests to the Nucleus Director
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DirectorRequest {
    /// Write a document (Osteon)
    WriteDocument { filename: String, content: String },
    /// Process logic/formula (Myocyte)
    ProcessLogic { name: String, formula: String },
    /// Record a heartbeat (Cardio)
    CardioHeartbeat,
    /// Get system status
    SystemStatus,
    /// List all documents
    ListDocuments,
    /// Help/usage information
    Help,
}

/// Response from the Nucleus Director
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DirectorResponse {
    /// Document saved successfully
    DocumentSaved {
        filename: String,
        block_offset: u64,
        size: usize,
    },
    /// Logic processed successfully
    LogicProcessed {
        name: String,
        block_offset: u64,
        bytecode_size: usize,
    },
    /// Heartbeat recorded successfully
    HeartbeatRecorded {
        tick: u64,
        uptime_secs: u64,
        block_offset: u64,
    },
    /// System status
    Status {
        biowerk_ready: bool,
        document_count: usize,
        logic_count: usize,
        heartbeat_tick: u64,
    },
    /// Document list
    DocumentList { count: usize, documents: Vec<String> },
    /// Help text
    HelpText(String),
    /// Error occurred
    Error(String),
}

// ============================================================================ 
// Task Planner (Hyperbolic Chamber Interface)
// ============================================================================ 

/// Task types for the Hyperbolic Chamber planner
#[derive(Debug, Clone)]
pub enum PlannedTask {
    /// Write blocks to storage
    WriteBlocks {
        block_count: usize,
        metadata: TaskMetadata,
    },
    /// Read blocks from storage
    ReadBlocks {
        addresses: Vec<u64>,
        metadata: TaskMetadata,
    },
}

/// Metadata for planned tasks
#[derive(Debug, Clone)]
pub struct TaskMetadata {
    pub operation: String,
    pub timestamp: u64, // Real kernel timestamp (TSC)
    pub priority: u8,
}

// ============================================================================ 
// Nucleus Director
// ============================================================================ 

/// The Nucleus Director orchestrates the full EAOS organism
pub struct NucleusDirector {
    biowerk: BIOwerk,
    cardio: CardioMonitor,
    synapse: Symbiote,
    pending_tasks: Vec<PlannedTask>,
}

impl Default for NucleusDirector {
    fn default() -> Self {
        Self::new()
    }
}

impl NucleusDirector {
    /// Create a new Nucleus Director
    pub fn new() -> Self {
        Self {
            biowerk: BIOwerk::new(),
            cardio: CardioMonitor::new(),
            synapse: Symbiote::new(),
            pending_tasks: Vec::new(),
        }
    }

    /// Process a high-level request
    pub fn process(&mut self, request: DirectorRequest) -> DirectorResponse {
        match request {
            DirectorRequest::WriteDocument { filename, content } => {
                self.write_document(&filename, &content)
            }
            DirectorRequest::ProcessLogic { name, formula } => {
                self.process_logic(&name, &formula)
            }
            DirectorRequest::CardioHeartbeat => {
                self.record_heartbeat()
            }
            DirectorRequest::SystemStatus => {
                DirectorResponse::Status {
                    biowerk_ready: true,
                    document_count: self.biowerk.osteon.document_count(),
                    logic_count: self.biowerk.myocyte.logic_count(),
                    heartbeat_tick: self.cardio.current_tick(),
                }
            }
            DirectorRequest::ListDocuments => {
                let addrs = self.biowerk.osteon.list_documents();
                DirectorResponse::DocumentList {
                    count: addrs.len(),
                    documents: addrs.iter().map(|a| format!("block:{}", a.block_offset())).collect(),
                }
            }
            DirectorRequest::Help => {
                DirectorResponse::HelpText(Self::help_text())
            }
        }
    }

    /// Record a heartbeat via Cardio organ
    fn record_heartbeat(&mut self) -> DirectorResponse {
        self.cardio.tick();
        let heartbeat = self.cardio.snapshot();
        let tick = heartbeat.tick;
        let uptime_secs = self.cardio.uptime_secs();
        let blob = heartbeat.to_blob();

        match self.synapse.commit_organ_data(blob) {
            Ok(addr) => {
                self.pending_tasks.push(PlannedTask::WriteBlocks {
                    block_count: 1,
                    metadata: TaskMetadata {
                        operation: format!("CardioHeartbeat:{}", tick),
                        timestamp: get_kernel_time(),
                        priority: 2,
                    },
                });

                DirectorResponse::HeartbeatRecorded {
                    tick,
                    uptime_secs,
                    block_offset: addr.block_offset(),
                }
            }
            Err(e) => DirectorResponse::Error(format!("Heartbeat failed: {:?}", e)),
        }
    }

    /// Write a document via Osteon
    fn write_document(&mut self, filename: &str, content: &str) -> DirectorResponse {
        let response = self.biowerk.process(AgentRequest::WriteDocument {
            filename: filename.to_string(),
            content: content.to_string(),
            timestamp: get_kernel_time(),
        });

        match response {
            AgentResponse::DocumentSaved { filename, address, size } => {
                self.pending_tasks.push(PlannedTask::WriteBlocks {
                    block_count: 1,
                    metadata: TaskMetadata {
                        operation: format!("WriteDocument:{}", filename),
                        timestamp: get_kernel_time(),
                        priority: 1,
                    },
                });

                DirectorResponse::DocumentSaved {
                    filename,
                    block_offset: address.block_offset(),
                    size,
                }
            }
            AgentResponse::Error(e) => DirectorResponse::Error(e),
            _ => DirectorResponse::Error("Unexpected response from Osteon".to_string()),
        }
    }

    /// Process logic via Myocyte
    fn process_logic(&mut self, name: &str, formula: &str) -> DirectorResponse {
        let response = self.biowerk.process(AgentRequest::ProcessLogic {
            name: name.to_string(),
            formula: formula.to_string(),
        });

        match response {
            AgentResponse::LogicProcessed { name, address, bytecode_size } => {
                self.pending_tasks.push(PlannedTask::WriteBlocks {
                    block_count: 1,
                    metadata: TaskMetadata {
                        operation: format!("ProcessLogic:{}", name),
                        timestamp: get_kernel_time(),
                        priority: 1,
                    },
                });

                DirectorResponse::LogicProcessed {
                    name,
                    block_offset: address.block_offset(),
                    bytecode_size,
                }
            }
            AgentResponse::Error(e) => DirectorResponse::Error(e),
            _ => DirectorResponse::Error("Unexpected response from Myocyte".to_string()),
        }
    }

    /// Parse a command string into a DirectorRequest
    pub fn parse_command(input: &str) -> Option<DirectorRequest> {
        let input = input.trim();
        let mut parts = input.splitn(2, ' ');
        let cmd = parts.next()?.to_lowercase();
        let rest = parts.next();

        match cmd.as_str() {
            "write" | "doc" => {
                if let Some(r) = rest {
                    let mut file_content = r.splitn(2, ' ');
                    let fname = file_content.next()?.to_string();
                    let content = file_content.next()?.to_string();
                    Some(DirectorRequest::WriteDocument { filename: fname, content })
                } else {
                    None
                }
            }
            "logic" | "calc" => {
                if let Some(r) = rest {
                    let mut name_formula = r.splitn(2, ' ');
                    let name = name_formula.next()?.to_string();
                    let formula = name_formula.next()?.to_string();
                    Some(DirectorRequest::ProcessLogic { name, formula })
                } else {
                    None
                }
            }
            "cardio" | "heartbeat" | "pulse" => Some(DirectorRequest::CardioHeartbeat),
            "status" => Some(DirectorRequest::SystemStatus),
            "list" => Some(DirectorRequest::ListDocuments),
            "help" | "?" => Some(DirectorRequest::Help),
            _ => None,
        }
    }

    /// Get help text
    pub fn help_text() -> String {
        "EAOS Nucleus Director - Office Suite Commands\n\n"
        .to_string()
    }

    pub fn pending_task_count(&self) -> usize {
        self.pending_tasks.len()
    }

    pub fn biowerk(&self) -> &BIOwerk {
        &self.biowerk
    }
}

// ============================================================================ 
// Kernel Interop (Always Real Code)
// ============================================================================ 

/// Get real monotonic time from the Referee kernel via syscall 7
fn get_kernel_time() -> u64 {
    #[cfg(feature = "std")]
    {
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .map(|d| d.as_secs())
            .unwrap_or(0)
    }
    #[cfg(not(feature = "std"))]
    {
        let mut result: u64;
        unsafe {
            core::arch::asm!(
                "syscall",
                in("rax") 7u64, // SyscallNumber::GetTime
                out("rax") result,
                options(nostack, nomem)
            );
        }
        result
    }
}

mod thalamus;
mod font;
mod visual_cortex;

use thalamus::{Thalamus, Stimulus};
use visual_cortex::{VisualCortex, Color};
use ed25519_dalek::{Signer, SigningKey};
use blake3::Hash;

// ...

/// Nucleus Trusted Entry Point (Stage 8 Manifestation)
///
/// This is the terminal destination of the UEFI boot chain:
/// Referee -> Preloader -> Nucleus
#[no_mangle]
pub extern "C" fn boot_entry(params: *const BootParameters) -> ! {
    let params = unsafe {
        if params.is_null() || (*params).magic != 0xEA05_B007 {
            loop { core::hint::spin_loop(); } // Invalid handoff
        }
        &*params
    };

    // Initialize the Sovereign Director
    let mut director = NucleusDirector::new();
    let mut thalamus = Thalamus::new(params);
    
    // Initialize Visual Cortex (The Retina)
    let mut visual = VisualCortex::new(params);
    if let Some(ref mut v) = visual {
        v.clear(Color::VOID);
        v.draw_text(20, 20, "EAOS Nucleus v1.0", Color::LIFE);
        v.draw_text(20, 40, "Sensory Cortex: ONLINE", Color::SYNAPSE);
    }
    
    // Derive signing key from master key (using it as seed)
    let signing_key = SigningKey::from_bytes(&params.master_key);

    // Nucleus Event Loop
    loop {
        // A. Tick: Update biological time
        let now = get_kernel_time();
        
        // Visual Heartbeat
        if let Some(ref mut v) = visual {
            let pulse = if (now / 1000) % 2 == 0 { Color::ALERT } else { Color::DORMANT }; // Assuming now is TSC/micros
            // Draw small square in top right
            v.draw_rect(v.width - 30, 20, 10, 10, pulse);
        }

        // B. Sense: The Thalamus acts as the filter
        let stimulus = thalamus.fetch_next_stimulus();

        // C. Think: Process the stimulus or dream (idle processing)
        if let Some(Stimulus::Volition(cmd_bytes)) = stimulus {
             if let Ok(cmd_str) = alloc::string::String::from_utf8(cmd_bytes) {
                 // Echo command to screen
                 if let Some(ref mut v) = visual {
                     v.draw_text(20, 60, "CMD: ", Color::TEXT);
                     v.draw_text(60, 60, &cmd_str, Color::LIFE);
                 }
                 
                 if let Some(request) = NucleusDirector::parse_command(&cmd_str) {
                     let _response = director.process(request);
                     // TODO: Output response via Symbiote/Console
                 }
             }
        } else {
            // Dream / Heartbeat
            director.process(DirectorRequest::CardioHeartbeat);
        }

        // D. Act: Manifest Will (Broca's Area) - Process pending tasks
        // In a real system, we'd sign these tasks and submit them.
        
        // E. Rest: Yield to kernel
        #[cfg(not(feature = "std"))]
        unsafe {
            core::arch::asm!("syscall", in("rax") 3u64); // SyscallNumber::Yield
        }
    }
}