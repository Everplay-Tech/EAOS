//! Pluggable policy engine that evaluates ledger events against declarative rules.
//!
//! The engine consumes [`ledger_spec::events::LedgerEvent`] instances, evaluates
//! them against a set of declarative [`ledger_spec::policy::PolicyDefinition`]
//! bundles, and emits signed policy decisions plus optional alerts back onto
//! the ledger. Built-in policies cover export control and command approval.

use std::collections::HashMap;

use anyhow::Result;
use ed25519_dalek::SigningKey;
use ledger_spec::events::{
    AgencyEvent, Audience, AuditEvent, DataSensitivity, EventKind, LedgerEvent, LifecycleCommand,
    LifecycleUpdate, MuscleEvent, PrivacyEvent,
};
use ledger_spec::policy::{
    PolicyAlert, PolicyAlertSeverity, PolicyBinding, PolicyDecision, PolicyDefinition,
    PolicyEffect, PolicyId, PolicyRule, PolicyScope,
};
use ledger_spec::{Envelope, PublicKey, SchemaVersion};

use crate::signing;

/// Outcome of evaluating a ledger event against configured policies.
#[derive(Debug, Clone)]
pub struct PolicyEvaluation {
    /// Final decision emitted by the engine.
    pub decision: PolicyDecision,
    /// Alerts produced during evaluation (blocking/justification/reroute).
    pub alerts: Vec<PolicyAlert>,
}

/// Signed envelopes for the decision and any alerts generated by the engine.
#[derive(Debug, Clone)]
pub struct PolicyOutputs {
    /// Evaluation result.
    pub evaluation: PolicyEvaluation,
    /// Decision event envelope (signed).
    pub decision_envelope: Envelope,
    /// Alert envelopes (signed), paired with the alert they contain.
    pub alert_envelopes: Vec<(PolicyAlert, Envelope)>,
}

/// Policy engine with pluggable definitions and built-in policies.
#[derive(Debug)]
pub struct PolicyEngine {
    policies: HashMap<String, PolicyDefinition>,
    signer: SigningKey,
    policy_channel: String,
    schema_version: SchemaVersion,
}

impl PolicyEngine {
    /// Create a new engine with no policies.
    pub fn new(
        signer: SigningKey,
        policy_channel: impl Into<String>,
        schema_version: SchemaVersion,
    ) -> Self {
        Self {
            policies: HashMap::new(),
            signer,
            policy_channel: policy_channel.into(),
            schema_version,
        }
    }

    /// Create an engine preloaded with built-in export control and command approval policies.
    pub fn with_builtin_policies(
        signer: SigningKey,
        policy_channel: impl Into<String>,
        schema_version: SchemaVersion,
    ) -> Self {
        let mut engine = Self::new(signer, policy_channel, schema_version);
        for policy in builtin_policies() {
            engine.upsert_policy(policy);
        }
        engine
    }

    /// Expose the signer public key used for emitted decisions.
    pub fn issuer(&self) -> PublicKey {
        self.signer.verifying_key().to_bytes()
    }

    /// Register or replace a policy definition.
    pub fn upsert_policy(&mut self, policy: PolicyDefinition) -> Option<PolicyDefinition> {
        self.policies.insert(policy_key(&policy.id), policy)
    }

    /// Evaluate an event and return the resulting decision and alerts.
    pub fn evaluate(&self, event: &LedgerEvent, justification: Option<String>) -> PolicyEvaluation {
        let ctx = PolicyContext::from_event(event);
        let mut bindings = Vec::new();
        let mut final_effect = PolicyEffect::Allow;
        let mut routed_audience = None;
        let mut alerts = Vec::new();

        for policy in self.policies.values() {
            for rule in &policy.rules {
                if !rule_matches(rule, &ctx) {
                    continue;
                }
                let effect = rule.effect.clone();
                bindings.push(PolicyBinding {
                    policy: policy.id.clone(),
                    rule_id: Some(rule.id.clone()),
                    effect: effect.clone(),
                });
                let (merged, routed) = merge_effect(final_effect, &effect);
                final_effect = merged;
                routed_audience = routed_audience.or(routed);
                if let Some(alert) =
                    alert_for_effect(event, &policy.id, &effect, rule.description.as_deref())
                {
                    alerts.push(alert);
                }
            }
        }

        let decision = PolicyDecision {
            subject: event.id,
            scope: ctx.scope,
            bindings,
            final_effect,
            observed_tags: ctx.tags,
            origin: ctx.origin,
            routed_audience,
            justification,
            created_at: event.created_at,
        };

        PolicyEvaluation { decision, alerts }
    }

    /// Evaluate an event, emit the decision event, sign it, and sign any alerts produced.
    pub fn evaluate_and_sign(
        &self,
        event: &LedgerEvent,
        justification: Option<String>,
    ) -> Result<PolicyOutputs> {
        let evaluation = self.evaluate(event, justification);
        let decision_event = LedgerEvent::new(
            EventKind::Policy(ledger_spec::events::PolicyEvent::DecisionRecorded {
                decision: evaluation.decision.clone(),
            }),
            self.issuer(),
            evaluation
                .decision
                .routed_audience
                .clone()
                .unwrap_or(Audience::Broadcast),
            evaluation.decision.created_at,
            DataSensitivity::Internal,
            Vec::new(),
            Some(event.id),
        )?;
        let decision_envelope = self.sign_event(decision_event)?;

        let mut alert_envelopes = Vec::new();
        for alert in &evaluation.alerts {
            let alert_event = LedgerEvent::new(
                EventKind::Policy(ledger_spec::events::PolicyEvent::AlertRaised {
                    alert: alert.clone(),
                }),
                self.issuer(),
                evaluation
                    .decision
                    .routed_audience
                    .clone()
                    .unwrap_or(Audience::Broadcast),
                alert.created_at,
                DataSensitivity::Internal,
                Vec::new(),
                Some(event.id),
            )?;
            alert_envelopes.push((alert.clone(), self.sign_event(alert_event)?));
        }

        Ok(PolicyOutputs {
            evaluation,
            decision_envelope,
            alert_envelopes,
        })
    }

    fn sign_event(&self, event: LedgerEvent) -> Result<Envelope> {
        let mut env = event.into_envelope(self.policy_channel.clone(), self.schema_version)?;
        signing::sign_envelope(&mut env, &self.signer);
        Ok(env)
    }
}

fn policy_key(id: &PolicyId) -> String {
    format!("{}@{}", id.name, id.version)
}

#[derive(Debug, Clone)]
struct PolicyContext {
    scope: PolicyScope,
    tags: Vec<String>,
    origin: PublicKey,
    sensitivity: DataSensitivity,
    kind_label: String,
}

impl PolicyContext {
    fn from_event(event: &LedgerEvent) -> Self {
        let mut scope = PolicyScope::from(event.intent);
        if matches!(
            event.kind,
            EventKind::Muscle(MuscleEvent::LifecycleError(_))
                | EventKind::Policy(ledger_spec::events::PolicyEvent::AlertRaised { .. })
        ) {
            scope = PolicyScope::Alert;
        }
        Self {
            scope,
            tags: extract_policy_tags(&event.kind),
            origin: event.issuer,
            sensitivity: event.sensitivity,
            kind_label: event_kind_label(&event.kind),
        }
    }
}

fn extract_policy_tags(kind: &EventKind) -> Vec<String> {
    match kind {
        EventKind::Muscle(MuscleEvent::InvocationRequest { policy_tags, .. }) => {
            policy_tags.clone()
        }
        EventKind::Muscle(MuscleEvent::LifecycleCommand(cmd)) => match cmd {
            LifecycleCommand::Register { policy_tags, .. } => policy_tags.clone(),
            LifecycleCommand::Activate { policy_tags, .. } => policy_tags.clone(),
            _ => Vec::new(),
        },
        EventKind::Muscle(MuscleEvent::LifecycleUpdate(update)) => match update {
            LifecycleUpdate::Registered { policy_tags, .. } => policy_tags.clone(),
            LifecycleUpdate::Activated { policy_tags, .. } => policy_tags.clone(),
            _ => Vec::new(),
        },
        _ => Vec::new(),
    }
}

fn event_kind_label(kind: &EventKind) -> String {
    match kind {
        EventKind::Control(_) => "Control".into(),
        EventKind::Muscle(m) => match m {
            MuscleEvent::InvocationRequest { .. } => "Muscle.InvocationRequest".into(),
            MuscleEvent::InvocationResult { .. } => "Muscle.InvocationResult".into(),
            MuscleEvent::Telemetry { .. } => "Muscle.Telemetry".into(),
            MuscleEvent::LifecycleCommand(_) => "Muscle.LifecycleCommand".into(),
            MuscleEvent::LifecycleUpdate(_) => "Muscle.LifecycleUpdate".into(),
            MuscleEvent::LifecycleError(_) => "Muscle.LifecycleError".into(),
        },
        EventKind::Audit(audit) => match audit {
            AuditEvent::InferenceRequested { .. } => "Audit.InferenceRequested".into(),
            AuditEvent::InferenceLogged { .. } => "Audit.InferenceLogged".into(),
            AuditEvent::LogQuery { .. } => "Audit.LogQuery".into(),
            AuditEvent::LogResult { .. } => "Audit.LogResult".into(),
            AuditEvent::ExportRequest { .. } => "Audit.ExportRequest".into(),
            AuditEvent::ExportReady { .. } => "Audit.ExportReady".into(),
        },
        EventKind::Privacy(priv_event) => match priv_event {
            PrivacyEvent::ScanRequested { .. } => "Privacy.ScanRequested".into(),
            PrivacyEvent::FindingsReady { .. } => "Privacy.FindingsReady".into(),
            PrivacyEvent::ActionApplied { .. } => "Privacy.ActionApplied".into(),
        },
        EventKind::Agency(agency) => match agency {
            AgencyEvent::BrowserFetch { .. } => "Agency.BrowserFetch".into(),
            AgencyEvent::BrowserResult { .. } => "Agency.BrowserResult".into(),
            AgencyEvent::TerminalCommand { .. } => "Agency.TerminalCommand".into(),
            AgencyEvent::TerminalResult { .. } => "Agency.TerminalResult".into(),
            AgencyEvent::ModelLoad { .. } => "Agency.ModelLoad".into(),
        },
        EventKind::Policy(policy) => match policy {
            ledger_spec::events::PolicyEvent::DefinitionPublished { .. } => {
                "Policy.DefinitionPublished".into()
            }
            ledger_spec::events::PolicyEvent::DecisionRecorded { .. } => {
                "Policy.DecisionRecorded".into()
            }
            ledger_spec::events::PolicyEvent::AlertRaised { .. } => "Policy.AlertRaised".into(),
        },
    }
}

fn rule_matches(rule: &PolicyRule, ctx: &PolicyContext) -> bool {
    if !matches!(rule.scope, PolicyScope::Any) && rule.scope != ctx.scope {
        return false;
    }
    if let Some(min) = rule.min_sensitivity {
        if !sensitivity_at_least(ctx.sensitivity, min) {
            return false;
        }
    }
    if !rule.allowed_origins.is_empty() && !rule.allowed_origins.contains(&ctx.origin) {
        return false;
    }
    if !rule.match_event_kinds.is_empty() && !rule.match_event_kinds.contains(&ctx.kind_label) {
        return false;
    }
    if !rule.absent_tags.is_empty() {
        let tags: std::collections::HashSet<&str> = ctx.tags.iter().map(String::as_str).collect();
        if rule
            .absent_tags
            .iter()
            .any(|tag| tags.contains(tag.as_str()))
        {
            return false;
        }
    }
    if !rule.match_tags_any.is_empty()
        && !rule
            .match_tags_any
            .iter()
            .any(|tag| ctx.tags.iter().any(|t| t == tag))
    {
        return false;
    }
    true
}

fn sensitivity_at_least(actual: DataSensitivity, minimum: DataSensitivity) -> bool {
    fn rank(s: DataSensitivity) -> u8 {
        match s {
            DataSensitivity::Public => 0,
            DataSensitivity::Internal => 1,
            DataSensitivity::Confidential => 2,
            DataSensitivity::Restricted => 3,
        }
    }
    rank(actual) >= rank(minimum)
}

fn merge_effect(
    current: PolicyEffect,
    incoming: &PolicyEffect,
) -> (PolicyEffect, Option<Audience>) {
    match (&current, incoming) {
        (PolicyEffect::Block { .. }, _) => (current, None),
        (_, PolicyEffect::Block { reason }) => (
            PolicyEffect::Block {
                reason: reason.clone(),
            },
            None,
        ),
        (PolicyEffect::RequireJustification { .. }, _) => (current, None),
        (_, PolicyEffect::RequireJustification { reason }) => (
            PolicyEffect::RequireJustification {
                reason: reason.clone(),
            },
            None,
        ),
        (PolicyEffect::Reroute { audience, reason }, PolicyEffect::Reroute { .. }) => (
            PolicyEffect::Reroute {
                audience: audience.clone(),
                reason: reason.clone(),
            },
            Some(audience.clone()),
        ),
        (_, PolicyEffect::Reroute { audience, reason }) => (
            PolicyEffect::Reroute {
                audience: audience.clone(),
                reason: reason.clone(),
            },
            Some(audience.clone()),
        ),
        _ => (current, None),
    }
}

fn alert_for_effect(
    subject: &LedgerEvent,
    policy: &PolicyId,
    effect: &PolicyEffect,
    description: Option<&str>,
) -> Option<PolicyAlert> {
    match effect {
        PolicyEffect::Block { reason } => Some(PolicyAlert {
            subject: subject.id,
            policy: Some(policy.clone()),
            severity: PolicyAlertSeverity::Critical,
            message: format!(
                "{reason}{}",
                description
                    .map(|d| format!(" (policy: {d})"))
                    .unwrap_or_default()
            ),
            created_at: subject.created_at,
        }),
        PolicyEffect::RequireJustification { reason } => Some(PolicyAlert {
            subject: subject.id,
            policy: Some(policy.clone()),
            severity: PolicyAlertSeverity::Warning,
            message: format!(
                "{reason}{}",
                description
                    .map(|d| format!(" (policy: {d})"))
                    .unwrap_or_default()
            ),
            created_at: subject.created_at,
        }),
        _ => None,
    }
}

fn builtin_policies() -> Vec<PolicyDefinition> {
    vec![export_control_policy(), command_approval_policy()]
}

fn export_control_policy() -> PolicyDefinition {
    PolicyDefinition {
        id: PolicyId {
            name: "export-control".into(),
            version: 1,
        },
        description: "Minimal export control: block restricted exports and require justification for confidential flows."
            .into(),
        tags: vec!["export".into()],
        rules: vec![
            PolicyRule {
                id: "block-restricted-exports".into(),
                scope: PolicyScope::Command,
                description: Some(
                    "Prevent restricted payloads from leaving the boundary without explicit exemption."
                        .into(),
                ),
                match_tags_any: Vec::new(),
                absent_tags: Vec::new(),
                match_event_kinds: vec!["Audit.ExportRequest".into()],
                allowed_origins: Vec::new(),
                min_sensitivity: Some(DataSensitivity::Restricted),
                effect: PolicyEffect::Block {
                    reason: "restricted export denied".into(),
                },
            },
            PolicyRule {
                id: "justify-confidential-exports".into(),
                scope: PolicyScope::Command,
                description: Some(
                    "Confidential export requests must carry explicit operator justification."
                        .into(),
                ),
                match_tags_any: Vec::new(),
                absent_tags: Vec::new(),
                match_event_kinds: vec!["Audit.ExportRequest".into()],
                allowed_origins: Vec::new(),
                min_sensitivity: Some(DataSensitivity::Confidential),
                effect: PolicyEffect::RequireJustification {
                    reason: "confidential export requires justification".into(),
                },
            },
        ],
    }
}

fn command_approval_policy() -> PolicyDefinition {
    PolicyDefinition {
        id: PolicyId {
            name: "command-approval".into(),
            version: 1,
        },
        description:
            "Require approvals for privileged commands and route alerts for oversight review."
                .into(),
        tags: vec!["approval".into()],
        rules: vec![
            PolicyRule {
                id: "commands-require-approval".into(),
                scope: PolicyScope::Command,
                description: Some(
                    "Commands without an explicit approval tag must carry justification.".into(),
                ),
                match_tags_any: Vec::new(),
                absent_tags: vec!["approved".into()],
                match_event_kinds: vec![
                    "Agency.TerminalCommand".into(),
                    "Muscle.InvocationRequest".into(),
                ],
                allowed_origins: Vec::new(),
                min_sensitivity: None,
                effect: PolicyEffect::RequireJustification {
                    reason: "command requires approval".into(),
                },
            },
            PolicyRule {
                id: "reroute-lifecycle-alerts".into(),
                scope: PolicyScope::Alert,
                description: Some(
                    "Lifecycle alerts are mirrored to the oversight domain for review.".into(),
                ),
                match_tags_any: Vec::new(),
                absent_tags: Vec::new(),
                match_event_kinds: vec!["Muscle.LifecycleError".into()],
                allowed_origins: Vec::new(),
                min_sensitivity: None,
                effect: PolicyEffect::Reroute {
                    audience: Audience::Domain("oversight".into()),
                    reason: Some("oversight review required".into()),
                },
            },
        ],
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use ed25519_dalek::VerifyingKey;
    use rand_core::OsRng;

    fn signer() -> SigningKey {
        SigningKey::generate(&mut OsRng)
    }

    fn sample_event(kind: EventKind, sensitivity: DataSensitivity) -> LedgerEvent {
        let issuer = signer().verifying_key().to_bytes();
        LedgerEvent::new(
            kind,
            issuer,
            Audience::Broadcast,
            42,
            sensitivity,
            Vec::new(),
            None,
        )
        .expect("ledger event")
    }

    fn verify_signature(env: &Envelope, issuer: &VerifyingKey) {
        let env_hash = ledger_spec::envelope_hash(env);
        let signature = ed25519_dalek::Signature::from_bytes(&env.signatures[0].signature);
        issuer
            .verify_strict(&env_hash, &signature)
            .expect("signature should verify");
    }

    #[test]
    fn export_control_blocks_restricted() {
        let engine = PolicyEngine::with_builtin_policies(signer(), "policy.decisions", 1);
        let event = sample_event(
            EventKind::Audit(AuditEvent::ExportRequest {
                channel: "audit".into(),
                policy_hash: [0x11; 32],
                return_channel: "return".into(),
                justification: "export".into(),
                requester: [0u8; 32],
            }),
            DataSensitivity::Restricted,
        );
        let outputs = engine.evaluate_and_sign(&event, None).unwrap();
        assert!(matches!(
            outputs.evaluation.decision.final_effect,
            PolicyEffect::Block { .. }
        ));
        assert!(!outputs.evaluation.alerts.is_empty());
        assert_eq!(outputs.decision_envelope.signatures.len(), 1);
        let issuer = ed25519_dalek::VerifyingKey::from_bytes(&engine.issuer()).unwrap();
        verify_signature(&outputs.decision_envelope, &issuer);
    }

    #[test]
    fn commands_require_justification_without_approval_tag() {
        let engine = PolicyEngine::with_builtin_policies(signer(), "policy.decisions", 1);
        let event = sample_event(
            EventKind::Agency(AgencyEvent::TerminalCommand {
                command: "rm -rf /tmp".into(),
                return_channel: "audit".into(),
                justification: None,
            }),
            DataSensitivity::Internal,
        );
        let evaluation = engine.evaluate(&event, None);
        assert!(matches!(
            evaluation.decision.final_effect,
            PolicyEffect::RequireJustification { .. }
        ));

        let justification = Some("change-12345".into());
        let outputs = engine
            .evaluate_and_sign(&event, justification.clone())
            .unwrap();
        assert_eq!(outputs.decision_envelope.signatures.len(), 1);
        assert_eq!(outputs.evaluation.decision.justification, justification);
    }

    #[test]
    fn lifecycle_alerts_are_rerouted() {
        let engine = PolicyEngine::with_builtin_policies(signer(), "policy.decisions", 1);
        let event = sample_event(
            EventKind::Muscle(MuscleEvent::LifecycleError(
                ledger_spec::events::LifecycleError {
                    muscle: ledger_spec::events::MuscleRef {
                        id: [0xAA; 32],
                        version: 1,
                    },
                    stage: ledger_spec::events::LifecycleStage::Registered,
                    reason: "missing manifest".into(),
                },
            )),
            DataSensitivity::Internal,
        );
        let evaluation = engine.evaluate(&event, None);
        assert!(matches!(
            evaluation.decision.final_effect,
            PolicyEffect::Reroute { .. }
        ));
        assert_eq!(
            evaluation
                .decision
                .routed_audience
                .as_ref()
                .expect("routed audience"),
            &Audience::Domain("oversight".into())
        );
    }
}
