;; ============================================================================
;; PgBouncer Configuration for BIOwerk
;; Production-ready connection pooling for PostgreSQL
;; ============================================================================

[databases]
;; Database definitions
;; Format: database_name = host=hostname port=port dbname=database auth_user=user
biowerk = host=postgres port=5432 dbname=biowerk

;; You can add additional databases here:
;; biowerk_test = host=postgres port=5432 dbname=biowerk_test
;; biowerk_staging = host=postgres_staging port=5432 dbname=biowerk

[pgbouncer]
;; ============================================================================
;; Core Settings
;; ============================================================================

;; Listen address and port
listen_addr = 0.0.0.0
listen_port = 6432

;; Unix socket directory (disabled in Docker)
unix_socket_dir =

;; Authentication
auth_type = md5
auth_file = /etc/pgbouncer/userlist.txt

;; Admin users (can connect to pgbouncer virtual database)
admin_users = biowerk

;; Statistics users (can connect to pgbouncer stats database)
stats_users = biowerk

;; ============================================================================
;; Pooling Mode
;; ============================================================================
;; transaction - Transaction-based pooling (recommended for microservices)
;;               Connections are returned to pool after each transaction
;;               Best connection reuse, but cannot use session-level features
;;
;; session    - Session-based pooling (default PostgreSQL behavior)
;;              Connection held until client disconnects
;;              Safest, but less efficient pooling
;;
;; statement  - Statement-based pooling (most aggressive, use with caution)
;;              Connection returned after each statement
;;              Breaks multi-statement transactions

pool_mode = transaction

;; ============================================================================
;; Connection Limits
;; ============================================================================

;; Maximum number of client connections
;; Formula: (num_services * connections_per_service) + overhead
;; BIOwerk: 10 services * 5 connections + 50 overhead = 100
max_client_conn = 200

;; Default pool size per database (server connections)
;; This is the primary pool - connections kept alive
;; Tuning: Start with (max_expected_concurrent_queries / databases)
;; For BIOwerk: 30-50 concurrent queries typical
default_pool_size = 25

;; Minimum pool size (connections to maintain)
;; Ensures warm connections are always available
min_pool_size = 10

;; Reserve pool size (emergency connections)
;; Additional connections when default pool is exhausted
;; Used when default_pool_size is full but max_db_connections not reached
reserve_pool_size = 10

;; Maximum connections per database (including reserve)
;; This should be less than PostgreSQL max_connections
;; PostgreSQL default: 100, leave headroom for direct connections
max_db_connections = 50

;; Maximum connections per user per database
;; Prevents single user from monopolizing pool
max_user_connections = 50

;; ============================================================================
;; Timeouts and Lifetimes
;; ============================================================================

;; Server idle timeout (seconds)
;; Close server connection if idle for this long
;; Balance: too low = frequent reconnects, too high = wasted connections
server_idle_timeout = 600

;; Server lifetime (seconds)
;; Close server connection after this duration (regardless of activity)
;; Helps with connection rotation and prevents long-lived connection issues
server_lifetime = 3600

;; Server connect timeout (seconds)
;; Timeout for connecting to PostgreSQL backend
server_connect_timeout = 15

;; Query timeout (seconds)
;; Cancel query if it runs longer than this (0 = disabled)
;; Set to 0 to let application handle query timeouts
query_timeout = 0

;; Query wait timeout (seconds)
;; Client timeout when waiting for a server connection
;; If pool is full, client waits this long before error
query_wait_timeout = 120

;; Client idle timeout (seconds)
;; Disconnect client if idle for this long
client_idle_timeout = 0

;; Client login timeout (seconds)
;; Timeout for client to complete authentication
client_login_timeout = 60

;; Idle transaction timeout (seconds)
;; Close connection if in transaction but idle
;; Prevents abandoned transactions from holding connections
idle_transaction_timeout = 600

;; ============================================================================
;; Connection Health & Safety
;; ============================================================================

;; Server reset query
;; Run this query on connections before returning to pool
;; Ensures clean state: DISCARD ALL resets temp tables, sequences, etc.
server_reset_query = DISCARD ALL

;; Server check query
;; Query to validate server connection health
server_check_query = SELECT 1

;; Server check delay (seconds)
;; How often to run server_check_query on idle connections
server_check_delay = 30

;; Server round robin
;; Use round-robin for server connections (vs. LIFO)
;; 0 = LIFO (reuse same connections), 1 = round-robin (spread load)
server_round_robin = 0

;; ============================================================================
;; Logging & Monitoring
;; ============================================================================

;; Log connections
log_connections = 1

;; Log disconnections
log_disconnections = 1

;; Log pooler errors
log_pooler_errors = 1

;; Log statistics
log_stats = 1

;; Stats period (seconds)
;; How often to write stats to log
stats_period = 60

;; Verbose logging (0 = normal, 1 = verbose, 2 = debug)
;; Set to 0 in production, 1-2 for troubleshooting
verbose = 0

;; ============================================================================
;; Performance Tuning
;; ============================================================================

;; Application name prefix
;; Helps identify PgBouncer connections in PostgreSQL
application_name_add_host = 1

;; Packet buffer size (bytes)
;; Larger = better for large result sets, more memory
pkt_buf = 4096

;; Max packet size (bytes)
;; Must be same or larger than PostgreSQL max packet
max_packet_size = 2147483647

;; Listen backlog
;; TCP listen queue size
listen_backlog = 128

;; Disable pqexec
;; Force clients to use extended query protocol (recommended for safety)
disable_pqexec = 0

;; ============================================================================
;; DNS & Network
;; ============================================================================

;; DNS max TTL (seconds)
;; Cache DNS lookups for this long
dns_max_ttl = 3600

;; DNS nxdomain TTL (seconds)
;; Cache negative DNS lookups
dns_nxdomain_ttl = 900

;; DNS zone check period (seconds)
;; Re-check DNS zone for changes
dns_zone_check_period = 0

;; TCP keepalive settings
;; Enable TCP keepalive
tcp_keepalive = 1
tcp_keepcnt = 5
tcp_keepidle = 60
tcp_keepintvl = 10

;; TCP user timeout (milliseconds)
;; Drop connection if no ACK received for this long
tcp_user_timeout = 60000

;; ============================================================================
;; Security
;; ============================================================================

;; Ignore startup parameters
;; Parameters to ignore from client (security/compatibility)
ignore_startup_parameters = extra_float_digits

;; So far so good (SFSB) connect timeout
;; Allow SFSB mode for better connection reuse
so_reuseport = 0

;; Track extra parameters
;; Track parameters like search_path, timezone for connection pooling
;; Note: In transaction mode, these cannot be changed mid-transaction
track_extra_parameters = all

;; ============================================================================
;; Notes for Production Tuning
;; ============================================================================
;;
;; 1. Monitor these metrics:
;;    - cl_active: Active client connections
;;    - cl_waiting: Clients waiting for server connection
;;    - sv_active: Active server connections
;;    - sv_idle: Idle server connections
;;    - maxwait: Longest client wait time
;;
;; 2. Adjust pool sizes based on:
;;    - default_pool_size: If sv_idle is consistently high, reduce
;;                        If cl_waiting is consistently high, increase
;;    - max_client_conn: Set to 2-3x your expected concurrent clients
;;    - reserve_pool_size: Set to 20-30% of default_pool_size
;;
;; 3. Pool mode considerations:
;;    - transaction: Best for stateless microservices (recommended)
;;    - session: Use if you need temp tables, prepared statements
;;
;; 4. PostgreSQL settings to adjust:
;;    - max_connections: Should be > max_db_connections * num_pgbouncers + headroom
;;    - shared_buffers: Can reduce since fewer actual connections
;;
;; 5. Monitoring queries:
;;    - Show stats: SHOW STATS;
;;    - Show pools: SHOW POOLS;
;;    - Show clients: SHOW CLIENTS;
;;    - Show servers: SHOW SERVERS;
;;
;; Connect to admin console: psql -h pgbouncer -p 6432 -U biowerk pgbouncer
;;
;; ============================================================================
