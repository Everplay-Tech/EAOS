<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON // SYSTOLE</title>
    <style>
        :root {
            --bio-green: #39ff14;
            --bio-green-dim: rgba(57, 255, 20, 0.6);
            --void: #050505;
            --grid-line: rgba(57, 255, 20, 0.15);
            --alert-red: #ff3939;
            --throttle-yellow: #ffcc00;
            --font-stack: 'SF Mono', 'Fira Code', 'Consolas', monospace;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--void);
            color: var(--bio-green);
            font-family: var(--font-stack);
            display: grid;
            grid-template-columns: 1fr 1.2fr 1fr;
            grid-template-rows: 1fr auto;
            height: 100vh;
            overflow: hidden;
        }

        /* CRT scanline overlay */
        body::after {
            content: "";
            position: absolute;
            inset: 0;
            background:
                linear-gradient(rgba(18,16,16,0) 50%, rgba(0,0,0,0.25) 50%),
                linear-gradient(90deg, rgba(255,0,0,0.06), rgba(0,255,0,0.02), rgba(0,0,255,0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 999;
        }

        .pane {
            padding: 1.5rem;
            border-right: 1px solid var(--grid-line);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .pane:last-child {
            border-right: none;
        }

        .pane h2 {
            font-size: 11px;
            letter-spacing: 3px;
            color: var(--bio-green-dim);
            margin-bottom: 1.5rem;
            text-transform: uppercase;
        }

        /* Event Stream */
        #codex-feed {
            flex: 1;
            overflow-y: auto;
            font-size: 11px;
            line-height: 1.6;
        }

        #codex-feed::-webkit-scrollbar {
            width: 4px;
        }

        #codex-feed::-webkit-scrollbar-track {
            background: var(--void);
        }

        #codex-feed::-webkit-scrollbar-thumb {
            background: var(--grid-line);
        }

        .event-line {
            padding: 4px 0;
            border-bottom: 1px solid var(--grid-line);
            opacity: 0;
            animation: fadeIn 0.3s forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        .event-time {
            color: var(--bio-green-dim);
            margin-right: 8px;
        }

        .event-type {
            color: var(--bio-green);
            font-weight: bold;
        }

        .event-type.alert {
            color: var(--alert-red);
        }

        /* Telemetry Grid */
        .matrix-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            padding: 1rem 0;
        }

        .readout {
            background: rgba(57, 255, 20, 0.03);
            border: 1px solid var(--grid-line);
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
        }

        .val-text {
            font-size: 42px;
            font-weight: bold;
            display: block;
            text-shadow: 0 0 20px var(--bio-green);
        }

        .label-text {
            font-size: 10px;
            letter-spacing: 2px;
            color: var(--bio-green-dim);
            margin-top: 0.5rem;
        }

        .unit-text {
            font-size: 14px;
            color: var(--bio-green-dim);
        }

        /* Gauge */
        .gauge-container {
            width: 100%;
            height: 8px;
            background: var(--void);
            border: 1px solid var(--grid-line);
            margin-top: 1rem;
            overflow: hidden;
        }

        .gauge-fill {
            height: 100%;
            background: var(--bio-green);
            transition: width 0.1s linear;
            box-shadow: 0 0 10px var(--bio-green);
        }

        .gauge-fill.warning {
            background: var(--throttle-yellow);
            box-shadow: 0 0 10px var(--throttle-yellow);
        }

        .gauge-fill.critical {
            background: var(--alert-red);
            box-shadow: 0 0 10px var(--alert-red);
        }

        /* Status Indicators */
        .status-row {
            display: flex;
            gap: 1rem;
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--grid-line);
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--bio-green);
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background: var(--alert-red);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Control Rack */
        #command-rack {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .fader-group {
            background: rgba(57, 255, 20, 0.03);
            border: 1px solid var(--grid-line);
            padding: 1rem;
        }

        .fader-label {
            font-size: 10px;
            letter-spacing: 2px;
            color: var(--bio-green-dim);
            margin-bottom: 0.5rem;
        }

        .fader {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: var(--grid-line);
            outline: none;
            cursor: pointer;
        }

        .fader::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 24px;
            background: var(--bio-green);
            cursor: pointer;
            box-shadow: 0 0 10px var(--bio-green);
        }

        .btn-override {
            background: transparent;
            border: 1px solid var(--grid-line);
            color: var(--bio-green);
            padding: 12px 24px;
            font-family: var(--font-stack);
            font-size: 11px;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
        }

        .btn-override:hover {
            background: rgba(57, 255, 20, 0.1);
            border-color: var(--bio-green);
        }

        .btn-override:active {
            background: var(--bio-green);
            color: var(--void);
        }

        .btn-override.alert {
            border-color: var(--alert-red);
            color: var(--alert-red);
        }

        .btn-override.alert:hover {
            background: rgba(255, 57, 57, 0.1);
        }

        /* ============================================================
         * TACTILE COMMAND DECK - "If you can't feel it, you can't trust it."
         * ============================================================ */

        .tactile-deck {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            flex: 1;
        }

        .sovereign-knob {
            background: rgba(57, 255, 20, 0.03);
            border: 1px solid var(--grid-line);
            padding: 1.25rem;
            position: relative;
        }

        .sovereign-knob::before {
            content: attr(data-label);
            position: absolute;
            top: -10px;
            left: 12px;
            background: var(--void);
            padding: 0 8px;
            font-size: 9px;
            letter-spacing: 2px;
            color: var(--bio-green-dim);
        }

        /* Entropy Flux - Inertial Flywheel */
        .flywheel-track {
            width: 100%;
            height: 60px;
            position: relative;
            cursor: grab;
            touch-action: none;
        }

        .flywheel-track:active {
            cursor: grabbing;
        }

        .flywheel-indicator {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 40px;
            background: var(--bio-green);
            box-shadow: 0 0 15px var(--bio-green), 0 0 30px rgba(57, 255, 20, 0.3);
            transition: box-shadow 0.1s;
        }

        .flywheel-indicator.spinning {
            box-shadow: 0 0 25px var(--bio-green), 0 0 50px rgba(57, 255, 20, 0.5);
        }

        .flywheel-scale {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg,
                var(--grid-line) 0%,
                var(--bio-green-dim) 50%,
                var(--alert-red) 100%
            );
        }

        /* Net Choke - Hydraulic Resistance Fader */
        .hydraulic-track {
            width: 100%;
            height: 120px;
            background: linear-gradient(180deg,
                rgba(255, 57, 57, 0.2) 0%,
                rgba(57, 255, 20, 0.05) 100%
            );
            border: 1px solid var(--grid-line);
            position: relative;
            cursor: ns-resize;
            touch-action: none;
        }

        .hydraulic-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg,
                var(--alert-red) 0%,
                var(--throttle-yellow) 50%,
                var(--bio-green) 100%
            );
            opacity: 0.7;
            transition: opacity 0.1s;
        }

        .hydraulic-fill.engaged {
            opacity: 1;
            filter: drop-shadow(0 0 10px var(--bio-green));
        }

        .hydraulic-value {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px var(--void);
        }

        /* Verbosity - Mechanical Ratchet */
        .ratchet-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            padding: 0.5rem 0;
        }

        .ratchet-knob {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%,
                var(--void) 0%,
                #0a0a0a 50%,
                var(--void) 100%
            );
            border: 2px solid var(--bio-green-dim);
            position: relative;
            cursor: pointer;
            touch-action: none;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.5);
        }

        .ratchet-knob::after {
            content: "";
            position: absolute;
            top: 8px;
            left: 50%;
            transform: translateX(-50%);
            width: 4px;
            height: 16px;
            background: var(--bio-green);
            border-radius: 2px;
            box-shadow: 0 0 8px var(--bio-green);
        }

        .ratchet-steps {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 10px;
        }

        .ratchet-step {
            padding: 4px 12px;
            border: 1px solid var(--grid-line);
            color: var(--bio-green-dim);
            transition: all 0.1s;
        }

        .ratchet-step.active {
            border-color: var(--bio-green);
            color: var(--bio-green);
            background: rgba(57, 255, 20, 0.1);
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3);
        }

        /* Mem Acid - Deadman Switch */
        .deadman-container {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .arm-toggle {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .arm-toggle input[type="checkbox"] {
            display: none;
        }

        .arm-switch {
            width: 48px;
            height: 24px;
            background: var(--void);
            border: 1px solid var(--alert-red);
            border-radius: 12px;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .arm-switch::after {
            content: "";
            position: absolute;
            top: 3px;
            left: 3px;
            width: 16px;
            height: 16px;
            background: var(--alert-red);
            border-radius: 50%;
            transition: all 0.2s;
        }

        .arm-toggle input:checked + .arm-switch {
            background: rgba(255, 57, 57, 0.3);
            box-shadow: 0 0 15px var(--alert-red);
        }

        .arm-toggle input:checked + .arm-switch::after {
            left: 27px;
        }

        .arm-label {
            font-size: 10px;
            letter-spacing: 2px;
            color: var(--alert-red);
        }

        .deadman-track {
            width: 100%;
            height: 40px;
            background: var(--void);
            border: 1px solid var(--grid-line);
            position: relative;
            cursor: not-allowed;
            touch-action: none;
            overflow: hidden;
        }

        .deadman-track.armed {
            cursor: ew-resize;
            border-color: var(--alert-red);
        }

        .deadman-fill {
            height: 100%;
            width: 0%;
            background: repeating-linear-gradient(45deg,
                var(--alert-red),
                var(--alert-red) 10px,
                #000 10px,
                #000 20px
            );
            transition: width 0.05s linear;
        }

        .deadman-track.danger-active .deadman-fill {
            box-shadow: 0 0 20px var(--alert-red);
            animation: hazardPulse 0.5s infinite;
        }

        @keyframes hazardPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .deadman-lock {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            letter-spacing: 2px;
            color: var(--bio-green-dim);
        }

        .deadman-track.armed .deadman-lock {
            display: none;
        }

        /* Physics feedback indicators */
        .engaged {
            filter: drop-shadow(0 0 10px var(--bio-green));
            border-color: #fff !important;
        }

        .danger-active {
            filter: drop-shadow(0 0 15px var(--alert-red));
        }

        /* Jitter animation for access denied */
        @keyframes jitter {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(4px); }
            75% { transform: translateX(-4px); }
        }

        .jitter {
            animation: jitter 0.2s ease-in-out;
        }

        /* ============================================================
         * PROJECT ARACHNID - Visual Cortex Pane
         * "The web is a trap. We are the spider."
         * ============================================================ */

        .arachnid-display {
            grid-column: 1 / -1;
            display: flex;
            flex-direction: column;
            background: #020202;
            border-top: 1px solid var(--grid-line);
            padding: 0;
            max-height: 280px;
            min-height: 200px;
        }

        .arachnid-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--grid-line);
            background: rgba(57, 255, 20, 0.02);
        }

        .arachnid-header h2 {
            font-size: 11px;
            letter-spacing: 3px;
            color: var(--bio-green-dim);
            margin: 0;
        }

        .spider-status {
            font-size: 10px;
            letter-spacing: 2px;
            padding: 4px 12px;
            border: 1px solid var(--grid-line);
            color: var(--bio-green-dim);
        }

        .spider-status.active {
            border-color: var(--bio-green);
            color: var(--bio-green);
            animation: pulse 1s infinite;
        }

        .spider-status.harvesting {
            border-color: var(--throttle-yellow);
            color: var(--throttle-yellow);
        }

        .spider-status.error {
            border-color: var(--alert-red);
            color: var(--alert-red);
        }

        .crt-screen {
            flex: 1;
            background: #050505;
            padding: 12px 15px;
            overflow-y: auto;
            position: relative;
            /* The Green Phosphor Look */
            color: var(--bio-green);
            font-family: 'VT323', 'Share Tech Mono', monospace;
            font-size: 14px;
            text-shadow: 0 0 4px rgba(57, 255, 20, 0.6);
            white-space: pre-wrap;
            line-height: 1.3;
            word-break: break-word;
        }

        .crt-screen::-webkit-scrollbar {
            width: 6px;
        }

        .crt-screen::-webkit-scrollbar-track {
            background: #020202;
        }

        .crt-screen::-webkit-scrollbar-thumb {
            background: var(--grid-line);
        }

        /* CRT Scanline overlay */
        .crt-screen::after {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                rgba(18, 16, 16, 0) 50%,
                rgba(0, 0, 0, 0.25) 50%
            );
            background-size: 100% 4px;
            pointer-events: none;
        }

        /* System messages in the terminal */
        .sys-msg {
            color: var(--bio-green-dim);
            display: block;
        }

        /* Bookmark indicator */
        .bookmark-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 10px;
        }

        .bookmark-label {
            color: var(--bio-green);
            letter-spacing: 1px;
        }

        .bookmark-ip {
            color: var(--bio-green-dim);
            font-family: var(--font-stack);
        }

        .arachnid-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            border-top: 1px solid var(--grid-line);
            font-size: 10px;
            letter-spacing: 1px;
            color: var(--bio-green-dim);
        }

        .meta-readout {
            display: flex;
            gap: 2rem;
        }

        .meta-readout b {
            color: var(--bio-green);
        }

        /* Mode indicator */
        .mode-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .mode-badge {
            padding: 2px 8px;
            border: 1px solid var(--grid-line);
            font-size: 9px;
            letter-spacing: 2px;
        }

        .mode-badge.telemetry {
            border-color: var(--bio-green);
            color: var(--bio-green);
        }

        .mode-badge.arachnid {
            border-color: var(--throttle-yellow);
            color: var(--throttle-yellow);
        }

        /* Connection Status Bar */
        #connection-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 24px;
            background: var(--void);
            border-top: 1px solid var(--grid-line);
            display: flex;
            align-items: center;
            padding: 0 1rem;
            font-size: 10px;
            letter-spacing: 1px;
            z-index: 1000;
        }

        #connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #uptime {
            margin-left: auto;
            color: var(--bio-green-dim);
        }
    </style>
</head>
<body>
    <section class="pane">
        <h2>KERNEL.EVENT_STREAM</h2>
        <div id="codex-feed"></div>
    </section>

    <section class="pane">
        <h2>SYSTEM_TELEMETRY</h2>
        <div class="matrix-grid">
            <div class="readout">
                <span id="cpu-val" class="val-text">0.0</span>
                <span class="unit-text">%</span>
                <span class="label-text">CPU_LOAD</span>
                <div class="gauge-container">
                    <div id="cpu-gauge" class="gauge-fill" style="width: 0%"></div>
                </div>
            </div>
            <div class="readout">
                <span id="mem-val" class="val-text">0.0</span>
                <span class="unit-text">%</span>
                <span class="label-text">MEM_PRESSURE</span>
                <div class="gauge-container">
                    <div id="mem-gauge" class="gauge-fill" style="width: 0%"></div>
                </div>
            </div>
            <div class="readout">
                <span id="pps-rx-val" class="val-text">0</span>
                <span class="unit-text">pkt/s</span>
                <span class="label-text">RX_RATE</span>
            </div>
            <div class="readout">
                <span id="pps-tx-val" class="val-text">0</span>
                <span class="unit-text">pkt/s</span>
                <span class="label-text">TX_RATE</span>
            </div>
        </div>

        <div class="status-row">
            <div class="status-indicator">
                <div id="kernel-dot" class="status-dot"></div>
                <span>KERNEL_LINK</span>
            </div>
            <div class="status-indicator">
                <div id="virtio-dot" class="status-dot"></div>
                <span>VIRTIO_NET</span>
            </div>
        </div>
    </section>

    <section class="pane">
        <h2>SOVEREIGN_CONTROLS</h2>
        <div class="tactile-deck">
            <!-- Entropy Flux: Inertial Flywheel -->
            <div class="sovereign-knob" data-label="ENTROPY_FLUX">
                <div class="flywheel-track" id="ctrl-entropy">
                    <div class="flywheel-indicator" id="entropy-indicator" style="left: 50%"></div>
                    <div class="flywheel-scale"></div>
                </div>
            </div>

            <!-- Net Choke: Hydraulic Resistance -->
            <div class="sovereign-knob" data-label="NET_CHOKE">
                <div class="hydraulic-track" id="ctrl-choke">
                    <div class="hydraulic-fill" id="choke-fill" style="height: 0%"></div>
                    <span class="hydraulic-value" id="choke-value">0%</span>
                </div>
            </div>

            <!-- Verbosity: Mechanical Ratchet -->
            <div class="sovereign-knob" data-label="VERBOSITY">
                <div class="ratchet-container">
                    <div class="ratchet-knob" id="ctrl-verb"></div>
                    <div class="ratchet-steps">
                        <div class="ratchet-step" data-level="4">TRACE</div>
                        <div class="ratchet-step" data-level="3">DEBUG</div>
                        <div class="ratchet-step active" data-level="2">INFO</div>
                        <div class="ratchet-step" data-level="1">WARN</div>
                        <div class="ratchet-step" data-level="0">ERROR</div>
                    </div>
                </div>
            </div>

            <!-- Mem Acid: Deadman Switch -->
            <div class="sovereign-knob" data-label="MEM_ACID">
                <div class="deadman-container">
                    <label class="arm-toggle">
                        <input type="checkbox" id="toggle-arm">
                        <div class="arm-switch"></div>
                        <span class="arm-label">ARM SYSTEM</span>
                    </label>
                    <div class="deadman-track" id="ctrl-acid">
                        <div class="deadman-fill" id="acid-fill"></div>
                        <span class="deadman-lock">LOCKED</span>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- PROJECT ARACHNID: Visual Cortex Pane -->
    <section class="arachnid-display">
        <div class="arachnid-header">
            <h2>ARACHNID // HYPERTEXT_HARVESTER</h2>
            <div class="bookmark-indicator">
                <span class="bookmark-label" id="bookmark-label">CLOUDFLARE_DNS</span>
                <span class="bookmark-ip" id="bookmark-ip">1.1.1.1</span>
            </div>
            <div class="spider-status" id="spider-status">IDLE</div>
        </div>

        <div class="crt-screen" id="arachnid-viewport">
            <span class="sys-msg">> SYSTEM_READY</span>
            <span class="sys-msg">> AWAITING_TARGET_DESIGNATION...</span>
            <span class="sys-msg">> ENTROPY_FLUX: Tune to select bookmark</span>
            <span class="sys-msg">> MEM_ACID: ARM + SLIDE to ignite</span>
        </div>

        <div class="arachnid-footer">
            <div class="meta-readout">
                <span>THROTTLE: <b id="disp-choke">0%</b></span>
                <span>BYTES: <b id="disp-bytes">0</b></span>
                <span>FILTER: <b>ACID_BATH</b></span>
            </div>
            <div class="mode-indicator">
                <span>MODE:</span>
                <span class="mode-badge telemetry" id="mode-telemetry">TELEMETRY</span>
                <span class="mode-badge" id="mode-arachnid">ARACHNID</span>
            </div>
        </div>
    </section>

    <div id="connection-bar">
        <div id="connection-status">
            <div id="ws-dot" class="status-dot disconnected"></div>
            <span id="ws-status">DISCONNECTED</span>
        </div>
        <span id="uptime">UPTIME: --:--:--</span>
    </div>

    <script>
        // BIO-S/1.0 Protocol Constants
        const BIO_MAGIC = 0xEA01EA01;
        const BIO_FRAME_SIZE = 32;

        // BioFrame offsets (SeqLock protocol)
        const OFF_SEQ = 0;           // u32: sequence counter
        const OFF_MAGIC = 4;         // u32: sync word
        const OFF_CPU = 8;           // u16: cpu pressure
        const OFF_MEM = 10;          // u16: mem pressure
        const OFF_PPS_RX = 12;       // u32: packets/sec RX
        const OFF_PPS_TX = 16;       // u32: packets/sec TX
        const OFF_UPTIME = 20;       // u64: system uptime
        const OFF_FLAGS = 28;        // u32: status flags

        // ====================================================================
        // BIO-STREAM Protocol Constants (Phase 2: ARACHNID Ring Buffer)
        // ====================================================================
        const BIOSTREAM_MAGIC = 0xB10573A1;
        const BIOSTREAM_CAPACITY = 65536;
        const BIOSTREAM_HEADER_SIZE = 0x20;  // 32 bytes header

        // BioStream offsets (ring buffer protocol)
        const BS_OFF_MAGIC = 0;           // u32: magic number
        const BS_OFF_CAPACITY = 4;        // u32: buffer capacity
        const BS_OFF_WRITE_HEAD = 8;      // u32: write position
        const BS_OFF_READ_TAIL = 12;      // u32: read position
        const BS_OFF_STATE = 16;          // u8: spider state
        const BS_OFF_BOOKMARK = 17;       // u8: bookmark index
        const BS_OFF_ERROR = 18;          // u8: error code
        const BS_OFF_HARVESTED = 20;      // u32: bytes harvested
        const BS_OFF_DATA = 32;           // data[65536]: ring buffer

        // State with LERP targets for smooth animation
        const state = {
            cpu: 0, targetCpu: 0,
            mem: 0, targetMem: 0,
            ppsRx: 0, targetPpsRx: 0,
            ppsTx: 0, targetPpsTx: 0,
            uptime: 0,
            flags: 0,
            lastFlags: 0,  // For edge detection of flag changes
            connected: false,
            lastPacket: 0
        };

        // WebSocket connection
        let ws = null;
        const WS_URL = `ws://${window.location.hostname}:8080/bio`;

        function connect() {
            if (ws && ws.readyState === WebSocket.OPEN) return;

            ws = new WebSocket(WS_URL);
            ws.binaryType = 'arraybuffer';

            ws.onopen = () => {
                state.connected = true;
                updateConnectionStatus(true);
                commandDeck.setSocket(ws);  // Link command deck to socket
                logEvent('SYSTEM', 'WebSocket connected to kernel bridge');
                logEvent('SYSTEM', 'Tactile controls ONLINE');
            };

            ws.onclose = () => {
                state.connected = false;
                updateConnectionStatus(false);
                commandDeck.setSocket(null);  // Disconnect command deck
                logEvent('ALERT', 'Connection lost - reconnecting...');
                setTimeout(connect, 2000);
            };

            ws.onerror = (err) => {
                logEvent('ALERT', 'WebSocket error');
            };

            ws.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer) {
                    handleBioFrame(event.data);
                }
            };
        }

        // ====================================================================
        // BIO-STREAM WebSocket (Phase 2: ARACHNID Ring Buffer Consumer)
        // ====================================================================

        const WS_STREAM_URL = `ws://${window.location.hostname}:8080/bio-stream`;

        /**
         * Connect to BIO-STREAM endpoint for live kernel data
         */
        function connectBioStream() {
            if (arachnid.wsStream && arachnid.wsStream.readyState === WebSocket.OPEN) return;

            arachnid.wsStream = new WebSocket(WS_STREAM_URL);
            arachnid.wsStream.binaryType = 'arraybuffer';

            arachnid.wsStream.onopen = () => {
                logEvent('ARACHNID', 'BIO-STREAM connected');
                addSystemMessage('KERNEL_LINK: ESTABLISHED');
            };

            arachnid.wsStream.onclose = () => {
                logEvent('ARACHNID', 'BIO-STREAM disconnected');
                arachnid.wsStream = null;
            };

            arachnid.wsStream.onerror = () => {
                logEvent('ALERT', 'BIO-STREAM error');
                arachnid.wsStream = null;
            };

            arachnid.wsStream.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer) {
                    handleBioStreamFrame(event.data);
                }
            };
        }

        /**
         * Disconnect from BIO-STREAM
         */
        function disconnectBioStream() {
            if (arachnid.wsStream) {
                arachnid.wsStream.close();
                arachnid.wsStream = null;
            }
        }

        /**
         * Handle BIO-STREAM binary frame (ring buffer snapshot)
         *
         * Protocol:
         * - Magic: 0xB10573A1 at offset 0
         * - write_head at offset 8 (u32)
         * - read_tail at offset 12 (u32) - we update this
         * - state at offset 16 (u8)
         * - bookmark_idx at offset 17 (u8)
         * - data at offset 32 (ring buffer)
         */
        function handleBioStreamFrame(buffer) {
            if (buffer.byteLength < BIOSTREAM_HEADER_SIZE) return;

            const dv = new DataView(buffer);

            // Validate magic number
            const magic = dv.getUint32(BS_OFF_MAGIC, true);
            if (magic !== BIOSTREAM_MAGIC) {
                logEvent('ALERT', `Invalid BIO-STREAM magic: 0x${magic.toString(16).toUpperCase()}`);
                return;
            }

            // Read header fields
            const capacity = dv.getUint32(BS_OFF_CAPACITY, true);
            const writeHead = dv.getUint32(BS_OFF_WRITE_HEAD, true);
            const spiderState = dv.getUint8(BS_OFF_STATE);
            const bookmarkIdx = dv.getUint8(BS_OFF_BOOKMARK);
            const errorCode = dv.getUint8(BS_OFF_ERROR);
            const bytesHarvested = dv.getUint32(BS_OFF_HARVESTED, true);

            // Update spider state from kernel
            if (arachnid.spiderState !== spiderState) {
                arachnid.spiderState = spiderState;
                updateSpiderStatus(spiderState);
            }

            // Update bookmark from kernel
            if (arachnid.bookmarkIdx !== bookmarkIdx) {
                arachnid.bookmarkIdx = bookmarkIdx;
                updateBookmarkDisplay(bookmarkIdx);
            }

            // Handle errors
            if (errorCode !== 0) {
                addSystemMessage(`ERROR: Code ${errorCode}`);
            }

            // Drain ring buffer: read from lastTail to writeHead
            const dataOffset = BS_OFF_DATA;
            let tail = arachnid.lastTail;
            let bytesRead = 0;
            const maxBytesPerFrame = 1024; // Limit to prevent UI freeze

            // Calculate available bytes (handle wrap-around)
            let available = (writeHead - tail) & 0xFFFFFFFF;
            if (available > capacity) {
                // Overflow: we've fallen behind, skip to head
                tail = writeHead;
                available = 0;
                addSystemMessage('BUFFER_OVERRUN: Data lost');
            }

            // Read bytes with baud throttle simulation
            const bytesToRead = Math.min(available, maxBytesPerFrame);
            let textChunk = '';

            for (let i = 0; i < bytesToRead; i++) {
                const idx = (tail + i) % capacity;
                const byte = dv.getUint8(dataOffset + idx);

                // Only append printable ASCII
                if (byte >= 0x20 && byte <= 0x7E || byte === 0x0A || byte === 0x09) {
                    textChunk += String.fromCharCode(byte);
                }
                bytesRead++;
            }

            // Update tail position
            arachnid.lastTail = (tail + bytesRead) % capacity;

            // Append to viewport
            if (textChunk.length > 0) {
                appendToViewport(textChunk);
            }

            // Update harvested counter from kernel
            document.getElementById('disp-bytes').textContent = bytesHarvested;
        }

        // Zero-Copy BioFrame Parser with SeqLock Tearing Prevention
        //
        // SeqLock Protocol (Reader Side):
        // do {
        //   1. snapshot = seq
        //   2. memory barrier (implicit in JS single-thread)
        //   3. optimistic read of payload
        //   4. memory barrier (implicit in JS single-thread)
        // } while (snapshot is ODD || snapshot != seq)
        //
        // Note: WebSocket messages arrive as complete ArrayBuffers, so the
        // kernel-side SeqLock ensures consistency before sending. This JS
        // validation is defense-in-depth for mmap scenarios.
        //
        function handleBioFrame(buffer) {
            if (buffer.byteLength < BIO_FRAME_SIZE) return;

            const dv = new DataView(buffer);
            const MAX_RETRIES = 3;
            let retries = 0;

            while (retries < MAX_RETRIES) {
                // Step 1: Snapshot sequence counter
                const seqSnapshot = dv.getUint32(OFF_SEQ, true);

                // Check if write in progress (odd seq = writer active)
                if (seqSnapshot & 1) {
                    retries++;
                    continue;  // Retry
                }

                // Step 2: Validate magic word
                const magic = dv.getUint32(OFF_MAGIC, true);
                if (magic !== BIO_MAGIC) {
                    logEvent('ALERT', `Invalid magic: 0x${magic.toString(16).toUpperCase()}`);
                    return;
                }

                // Step 3: Optimistic read of all data fields
                const cpu = dv.getUint16(OFF_CPU, true);
                const mem = dv.getUint16(OFF_MEM, true);
                const ppsRx = dv.getUint32(OFF_PPS_RX, true);
                const ppsTx = dv.getUint32(OFF_PPS_TX, true);
                const uptime = Number(dv.getBigUint64(OFF_UPTIME, true));
                const flags = dv.getUint32(OFF_FLAGS, true);

                // Step 4: Re-read sequence counter to detect tearing
                const seqFinal = dv.getUint32(OFF_SEQ, true);

                // Step 5: Validation
                if (seqSnapshot !== seqFinal) {
                    // Seq changed during read - data is torn, retry
                    retries++;
                    logEvent('WARN', 'Frame torn - retrying');
                    continue;
                }

                // SUCCESS: Frame is consistent! Apply updates
                state.lastPacket = Date.now();
                state.targetCpu = cpu / 10;   // 0-1000 -> 0.0-100.0
                state.targetMem = mem / 10;
                state.targetPpsRx = ppsRx;
                state.targetPpsTx = ppsTx;
                state.uptime = uptime;
                state.flags = flags;

                // Check alert flags (only log on state change to reduce noise)
                if ((flags & 0x01) && !(state.lastFlags & 0x01)) {
                    logEvent('ALERT', 'System alert flag set');
                }
                if ((flags & 0x02) && !(state.lastFlags & 0x02)) {
                    logEvent('WARN', 'Throttle engaged');
                }
                state.lastFlags = flags;

                return;  // Success, exit loop
            }

            // Max retries exceeded
            logEvent('ERROR', `SeqLock failed after ${MAX_RETRIES} retries`);
        }

        // 60fps LERP Render Loop - Decoupled from network
        function render() {
            // Smooth interpolation for "hardware feel"
            const lerp = 0.08;
            state.cpu += (state.targetCpu - state.cpu) * lerp;
            state.mem += (state.targetMem - state.mem) * lerp;
            state.ppsRx += (state.targetPpsRx - state.ppsRx) * lerp;
            state.ppsTx += (state.targetPpsTx - state.ppsTx) * lerp;

            // Update display
            document.getElementById('cpu-val').textContent = state.cpu.toFixed(1);
            document.getElementById('mem-val').textContent = state.mem.toFixed(1);
            document.getElementById('pps-rx-val').textContent = Math.floor(state.ppsRx);
            document.getElementById('pps-tx-val').textContent = Math.floor(state.ppsTx);

            // Update gauges with color thresholds
            updateGauge('cpu-gauge', state.cpu);
            updateGauge('mem-gauge', state.mem);

            // Update uptime
            const secs = Math.floor(state.uptime / 1000);
            const h = Math.floor(secs / 3600);
            const m = Math.floor((secs % 3600) / 60);
            const s = secs % 60;
            document.getElementById('uptime').textContent =
                `UPTIME: ${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;

            // Check for stale data
            if (state.connected && Date.now() - state.lastPacket > 3000) {
                document.getElementById('kernel-dot').classList.add('disconnected');
            } else if (state.connected) {
                document.getElementById('kernel-dot').classList.remove('disconnected');
            }

            requestAnimationFrame(render);
        }

        function updateGauge(id, value) {
            const gauge = document.getElementById(id);
            gauge.style.width = `${Math.min(100, value)}%`;
            gauge.classList.remove('warning', 'critical');
            if (value > 80) gauge.classList.add('critical');
            else if (value > 60) gauge.classList.add('warning');
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('ws-dot');
            const status = document.getElementById('ws-status');
            dot.classList.toggle('disconnected', !connected);
            status.textContent = connected ? 'CONNECTED' : 'DISCONNECTED';
        }

        // Event logging
        const MAX_EVENTS = 50;
        function logEvent(type, message) {
            const feed = document.getElementById('codex-feed');
            const time = new Date().toLocaleTimeString('en-US', { hour12: false });
            const line = document.createElement('div');
            line.className = 'event-line';
            line.innerHTML = `<span class="event-time">${time}</span><span class="event-type ${type.toLowerCase()}">[${type}]</span> ${message}`;
            feed.insertBefore(line, feed.firstChild);

            // Trim old events
            while (feed.children.length > MAX_EVENTS) {
                feed.removeChild(feed.lastChild);
            }
        }

        // ================================================================
        // BIO-C/1.0 COMMAND DECK
        // "If you can't feel it, you can't trust it."
        // ================================================================

        const CMD = {
            ENTROPY: 0x01,
            CHOKE: 0x02,
            VERB: 0x03,
            ACID: 0x04
        };

        class BioCommandDeck {
            constructor(socket) {
                this.socket = socket;
                this.seq = 0;
                this.crcTable = this.genCRCTable();
            }

            setSocket(socket) {
                this.socket = socket;
            }

            dispatch(cmdId, value, flags = 0) {
                const buf = new ArrayBuffer(16);
                const view = new DataView(buf);

                // Bytes 0-1: Magic (0xB10C)
                view.setUint16(0, 0xB10C, true);
                // Bytes 2-3: Sequence ID
                view.setUint16(2, this.seq++, true);
                // Byte 4: Command ID
                view.setUint8(4, cmdId);
                // Byte 5: Flags
                view.setUint8(5, flags);
                // Bytes 6-7: Padding
                view.setUint16(6, 0, true);
                // Bytes 8-11: Payload (float32)
                view.setFloat32(8, value, true);

                // CRC32 over bytes 0-11
                let crc = 0 ^ (-1);
                const bytes = new Uint8Array(buf, 0, 12);
                for (let i = 0; i < 12; i++) {
                    crc = (crc >>> 8) ^ this.crcTable[(crc ^ bytes[i]) & 0xFF];
                }
                view.setUint32(12, (crc ^ (-1)) >>> 0, true);

                if (this.socket && this.socket.readyState === 1) {
                    this.socket.send(buf);
                    return true;
                }
                return false;
            }

            genCRCTable() {
                let table = [];
                for (let n = 0; n < 256; n++) {
                    let c = n;
                    for (let k = 0; k < 8; k++) {
                        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                    }
                    table[n] = c;
                }
                return table;
            }
        }

        // Global command deck instance
        const commandDeck = new BioCommandDeck(null);

        // ================================================================
        // TACTILE PHYSICS ENGINE
        // ================================================================

        function setupTactileControls() {
            // --- ENTROPY FLUX: Inertial Flywheel ---
            const entropy = document.getElementById('ctrl-entropy');
            const entropyIndicator = document.getElementById('entropy-indicator');
            let entropyVal = 0.5;
            let entropyVelocity = 0;

            entropy.addEventListener('pointerdown', (e) => {
                entropy.setPointerCapture(e.pointerId);
                entropy.dataset.lastX = e.clientX;
                entropyIndicator.classList.add('spinning');
            });

            entropy.addEventListener('pointermove', (e) => {
                if (!entropy.hasPointerCapture(e.pointerId)) return;

                const deltaX = e.clientX - parseFloat(entropy.dataset.lastX);
                entropy.dataset.lastX = e.clientX;

                // PHYSICS: INERTIAL FLYWHEEL
                // Add velocity based on swipe, momentum carries forward
                entropyVelocity += deltaX * 0.002;
            });

            entropy.addEventListener('pointerup', () => {
                entropyIndicator.classList.remove('spinning');
            });

            // Inertial decay loop
            function entropyPhysics() {
                // Apply velocity with friction
                entropyVal += entropyVelocity;
                entropyVelocity *= 0.95;  // Friction/decay

                // Clamp
                entropyVal = Math.max(0, Math.min(1, entropyVal));

                // Update UI
                entropyIndicator.style.left = `${entropyVal * 100}%`;

                // Send command when velocity significant
                if (Math.abs(entropyVelocity) > 0.001) {
                    commandDeck.dispatch(CMD.ENTROPY, entropyVal);

                    // ARACHNID: Update bookmark selection
                    const newIdx = entropyToBookmark(entropyVal);
                    if (newIdx !== arachnid.bookmarkIdx) {
                        arachnid.bookmarkIdx = newIdx;
                        updateBookmarkDisplay(newIdx);
                    }
                }

                requestAnimationFrame(entropyPhysics);
            }
            entropyPhysics();


            // --- NET CHOKE: Hydraulic Resistance ---
            const choke = document.getElementById('ctrl-choke');
            const chokeFill = document.getElementById('choke-fill');
            const chokeValue = document.getElementById('choke-value');
            let chokeVal = 0.0;

            choke.addEventListener('pointerdown', (e) => {
                choke.setPointerCapture(e.pointerId);
                choke.dataset.lastY = e.clientY;
                chokeFill.classList.add('engaged');
            });

            choke.addEventListener('pointermove', (e) => {
                if (!choke.hasPointerCapture(e.pointerId)) return;

                const rect = choke.getBoundingClientRect();
                const deltaY = parseFloat(choke.dataset.lastY) - e.clientY;

                // PHYSICS: HYDRAULIC DRAG
                // Resistance increases as value increases (1x -> 4x)
                // Simulates "pressure" of choking the network pipe
                const resistance = 1.0 + (chokeVal * 3.0);
                const range = rect.height;

                chokeVal += (deltaY / range) / resistance;
                chokeVal = Math.max(0, Math.min(1, chokeVal));

                chokeFill.style.height = `${chokeVal * 100}%`;
                chokeValue.textContent = `${Math.round(chokeVal * 100)}%`;
                choke.dataset.lastY = e.clientY;

                commandDeck.dispatch(CMD.CHOKE, chokeVal);

                // ARACHNID: Update baud throttle display
                updateChokeDisplay(chokeVal);
            });

            choke.addEventListener('pointerup', (e) => {
                choke.releasePointerCapture(e.pointerId);
                chokeFill.classList.remove('engaged');
            });


            // --- VERBOSITY: Mechanical Ratchet ---
            const knob = document.getElementById('ctrl-verb');
            const steps = document.querySelectorAll('.ratchet-step');
            const STEPS = 5;
            let verbLevel = 2;

            knob.addEventListener('pointerdown', (e) => {
                knob.setPointerCapture(e.pointerId);
                knob.dataset.startAngle = getAngle(knob, e);
            });

            function getAngle(elem, e) {
                const rect = elem.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                return Math.atan2(e.clientY - cy, e.clientX - cx);
            }

            knob.addEventListener('pointermove', (e) => {
                if (!knob.hasPointerCapture(e.pointerId)) return;

                const angle = getAngle(knob, e);
                // Map angle (-PI to PI) to 0-1
                const norm = (angle + Math.PI) / (2 * Math.PI);

                // PHYSICS: SNAP-TO-GRID (Mechanical Ratchet)
                const stepSize = 1 / (STEPS - 1);
                const snapped = Math.round(norm / stepSize) * stepSize;
                const discrete = Math.round(snapped * (STEPS - 1));

                if (discrete !== verbLevel) {
                    verbLevel = discrete;

                    // Rotate knob (300 degree range)
                    const rotation = (discrete / (STEPS - 1)) * 300 - 60;
                    knob.style.transform = `rotate(${rotation}deg)`;

                    // Haptic feedback
                    if (navigator.vibrate) navigator.vibrate(15);

                    // Update step indicators
                    steps.forEach(step => {
                        const level = parseInt(step.dataset.level);
                        step.classList.toggle('active', level === discrete);
                    });

                    // Send discrete value (0-4 mapped to 0.0-1.0)
                    commandDeck.dispatch(CMD.VERB, discrete / (STEPS - 1));
                    logEvent('CMD', `VERBOSITY: Level ${discrete}`);
                }
            });


            // --- MEM ACID: Deadman Switch ---
            const acid = document.getElementById('ctrl-acid');
            const acidFill = document.getElementById('acid-fill');
            const armToggle = document.getElementById('toggle-arm');
            let acidVal = 0.0;

            armToggle.addEventListener('change', () => {
                acid.classList.toggle('armed', armToggle.checked);
                if (armToggle.checked) {
                    logEvent('WARN', 'MEM_ACID: System ARMED');
                    logEvent('ARACHNID', 'Ready for ignition - slide to harvest');
                } else {
                    // Spring return when disarmed
                    acidVal = 0;
                    acidFill.style.width = '0%';
                    commandDeck.dispatch(CMD.ACID, 0.0, 0x00);
                    logEvent('SYSTEM', 'MEM_ACID: System SAFE');

                    // ARACHNID: Abort on disarm
                    handleArachnidIgnition(false, 0);
                }
            });

            acid.addEventListener('pointerdown', (e) => {
                if (!armToggle.checked) {
                    // ACCESS DENIED jitter
                    acid.classList.add('jitter');
                    setTimeout(() => acid.classList.remove('jitter'), 200);
                    logEvent('ALERT', 'MEM_ACID: ARM required');
                    return;
                }
                acid.setPointerCapture(e.pointerId);
                acid.dataset.lastX = e.clientX;
                acid.classList.add('danger-active');
            });

            acid.addEventListener('pointermove', (e) => {
                if (!acid.hasPointerCapture(e.pointerId)) return;

                const rect = acid.getBoundingClientRect();
                const delta = e.clientX - parseFloat(acid.dataset.lastX);

                acidVal = Math.max(0, Math.min(1, acidVal + (delta / rect.width)));
                acidFill.style.width = `${acidVal * 100}%`;
                acid.dataset.lastX = e.clientX;

                // Send with ARMED flag (0x01)
                commandDeck.dispatch(CMD.ACID, acidVal, 0x01);

                // ARACHNID: Check for ignition threshold
                handleArachnidIgnition(armToggle.checked, acidVal);
            });

            const releaseAcid = (e) => {
                if (!acid.hasPointerCapture(e.pointerId)) return;
                acid.releasePointerCapture(e.pointerId);
                acid.classList.remove('danger-active');

                // PHYSICS: SPRING RETURN - snaps back to safety
                acidVal = 0.0;
                acidFill.style.width = '0%';
                commandDeck.dispatch(CMD.ACID, 0.0, 0x00);
                logEvent('SYSTEM', 'MEM_ACID: Spring return to SAFE');

                // ARACHNID: Abort on release (deadman switch)
                handleArachnidIgnition(false, 0);
            };

            acid.addEventListener('pointerup', releaseAcid);
            acid.addEventListener('pointercancel', releaseAcid);
        }

        // ================================================================
        // PROJECT ARACHNID - Visual Cortex Controller
        // "The web is a trap. We are the spider."
        // ================================================================

        // Bookmark table (must match kernel's BOOKMARKS array)
        const BOOKMARKS = [
            { ip: '1.1.1.1', label: 'CLOUDFLARE_DNS', host: '1.1.1.1', path: '/' },
            { ip: '93.184.216.34', label: 'EXAMPLE_COM', host: 'example.com', path: '/' },
            { ip: '192.168.1.1', label: 'LOCAL_GATEWAY', host: '192.168.1.1', path: '/' },
            { ip: '10.0.0.1', label: 'INTERNAL_WIKI', host: '10.0.0.1', path: '/' },
            { ip: '127.0.0.1:8080', label: 'LOCALHOST', host: 'localhost', path: '/' },
        ];

        // Spider state enum (must match kernel)
        const SpiderState = {
            IDLE: 0,
            TUNING: 1,
            CONNECTING: 2,
            REQUESTING: 3,
            HARVESTING: 4,
            DISSOLVING: 5,
            COMPLETE: 6,
            ERROR: 7,
        };

        const SpiderStateNames = ['IDLE', 'TUNING', 'CONNECTING', 'REQUESTING', 'HARVESTING', 'DISSOLVING', 'COMPLETE', 'ERROR'];

        // ARACHNID state
        const arachnid = {
            mode: 'telemetry',  // 'telemetry' or 'arachnid'
            bookmarkIdx: 0,
            spiderState: SpiderState.IDLE,
            bytesHarvested: 0,
            streamBuffer: '',  // Accumulated text from ring buffer
            lastChokeValue: 0,
            // Phase 2: BIO-STREAM ring buffer consumer state
            lastTail: 0,       // Last read position in ring buffer
            wsStream: null,    // BIO-STREAM WebSocket connection
            demoMode: true,    // Use simulated content (false = live kernel)
        };

        // Map entropy value to bookmark index
        function entropyToBookmark(entropy) {
            const idx = Math.floor(entropy * BOOKMARKS.length);
            return Math.min(idx, BOOKMARKS.length - 1);
        }

        // Update bookmark display
        function updateBookmarkDisplay(idx) {
            const bm = BOOKMARKS[idx];
            document.getElementById('bookmark-label').textContent = bm.label;
            document.getElementById('bookmark-ip').textContent = bm.ip;
        }

        // Update spider status display
        function updateSpiderStatus(state) {
            const statusEl = document.getElementById('spider-status');
            statusEl.textContent = SpiderStateNames[state] || 'UNKNOWN';

            statusEl.classList.remove('active', 'harvesting', 'error');
            if (state === SpiderState.HARVESTING) {
                statusEl.classList.add('harvesting');
            } else if (state === SpiderState.ERROR) {
                statusEl.classList.add('error');
            } else if (state !== SpiderState.IDLE && state !== SpiderState.COMPLETE) {
                statusEl.classList.add('active');
            }
        }

        // Update mode badges
        function updateModeBadges() {
            const telBadge = document.getElementById('mode-telemetry');
            const araBadge = document.getElementById('mode-arachnid');

            if (arachnid.mode === 'telemetry') {
                telBadge.classList.add('telemetry');
                araBadge.classList.remove('arachnid');
            } else {
                telBadge.classList.remove('telemetry');
                araBadge.classList.add('arachnid');
            }
        }

        // Append text to ARACHNID viewport
        function appendToViewport(text) {
            const viewport = document.getElementById('arachnid-viewport');
            const textNode = document.createTextNode(text);
            viewport.appendChild(textNode);

            // Auto-scroll to bottom
            viewport.scrollTop = viewport.scrollHeight;

            arachnid.bytesHarvested += text.length;
            document.getElementById('disp-bytes').textContent = arachnid.bytesHarvested;
        }

        // Add system message to viewport
        function addSystemMessage(msg) {
            const viewport = document.getElementById('arachnid-viewport');
            const span = document.createElement('span');
            span.className = 'sys-msg';
            span.textContent = `> ${msg}`;
            viewport.appendChild(span);
            viewport.scrollTop = viewport.scrollHeight;
        }

        // Clear viewport
        function clearViewport() {
            const viewport = document.getElementById('arachnid-viewport');
            viewport.innerHTML = '';
            arachnid.bytesHarvested = 0;
            document.getElementById('disp-bytes').textContent = '0';
        }

        // Handle ARACHNID mode activation via MEM_ACID
        function handleArachnidIgnition(armed, slideValue) {
            if (!armed) {
                // Deadman released - abort if active
                if (arachnid.spiderState !== SpiderState.IDLE &&
                    arachnid.spiderState !== SpiderState.COMPLETE) {
                    addSystemMessage('CONNECTION_ABORTED (Deadman released)');
                    arachnid.spiderState = SpiderState.IDLE;
                    updateSpiderStatus(SpiderState.IDLE);

                    // Phase 2: Disconnect BIO-STREAM on abort
                    if (!arachnid.demoMode) {
                        disconnectBioStream();
                    }
                }
                return false;
            }

            // Slide > 0.5 to ignite
            if (slideValue > 0.5 && arachnid.spiderState === SpiderState.IDLE) {
                // Switch to ARACHNID mode
                arachnid.mode = 'arachnid';
                updateModeBadges();

                // Clear and prepare viewport
                clearViewport();
                arachnid.lastTail = 0;  // Reset ring buffer read position

                addSystemMessage('INITIATING_HARVEST');
                addSystemMessage(`TARGET: ${BOOKMARKS[arachnid.bookmarkIdx].label}`);
                addSystemMessage(`ADDRESS: ${BOOKMARKS[arachnid.bookmarkIdx].ip}`);
                addSystemMessage(`MODE: ${arachnid.demoMode ? 'DEMO' : 'LIVE_KERNEL'}`);
                addSystemMessage('CONNECTING...');

                arachnid.spiderState = SpiderState.CONNECTING;
                updateSpiderStatus(SpiderState.CONNECTING);

                logEvent('ARACHNID', `Igniting harvest: ${BOOKMARKS[arachnid.bookmarkIdx].label}`);

                // Phase 2: Choose between demo and live kernel mode
                if (arachnid.demoMode) {
                    simulateHarvest();
                } else {
                    // Connect to BIO-STREAM for live kernel data
                    connectBioStream();
                    addSystemMessage('KERNEL_LINK: Establishing...');
                }

                return true;
            }

            return false;
        }

        // Simulated harvest for demo mode (real implementation would use kernel)
        function simulateHarvest() {
            const bm = BOOKMARKS[arachnid.bookmarkIdx];

            // Simulate connection delay
            setTimeout(() => {
                if (arachnid.spiderState !== SpiderState.CONNECTING) return;

                arachnid.spiderState = SpiderState.REQUESTING;
                updateSpiderStatus(SpiderState.REQUESTING);
                addSystemMessage('SENDING_REQUEST...');

                // Simulate request delay
                setTimeout(() => {
                    if (arachnid.spiderState !== SpiderState.REQUESTING) return;

                    arachnid.spiderState = SpiderState.HARVESTING;
                    updateSpiderStatus(SpiderState.HARVESTING);
                    addSystemMessage('RESPONSE_RECEIVED');
                    addSystemMessage('ACID_BATH: Sanitizing stream...');
                    addSystemMessage('---');

                    // Stream simulated content
                    streamDemoContent();

                }, 500);
            }, 800);
        }

        // Stream demo content character by character
        function streamDemoContent() {
            const demoContent = `
Welcome to the World Wide Web.

This is a demonstration of PROJECT ARACHNID, the kernel-resident hypertext harvester.

All HTML tags have been DISSOLVED in the Acid Bath.
All scripts have been NEUTRALIZED.
All trackers have been ELIMINATED.

What remains is pure, sanitized text.

The NET_CHOKE control adjusts the baud rate:
- 0% = Full speed
- 100% = 300 baud (character by character)

You are seeing the internet as it was meant to be seen:
Raw. Pure. Text.

--- END OF TRANSMISSION ---
`;

            let idx = 0;
            function streamChar() {
                if (arachnid.spiderState !== SpiderState.HARVESTING) return;
                if (idx >= demoContent.length) {
                    arachnid.spiderState = SpiderState.COMPLETE;
                    updateSpiderStatus(SpiderState.COMPLETE);
                    addSystemMessage('---');
                    addSystemMessage('HARVEST_COMPLETE');
                    arachnid.mode = 'telemetry';
                    updateModeBadges();
                    return;
                }

                // Apply baud throttling from NET_CHOKE
                const baseDelay = 5;  // ms per char at full speed
                const maxDelay = 100; // ms per char at full choke
                const delay = baseDelay + (arachnid.lastChokeValue * (maxDelay - baseDelay));

                appendToViewport(demoContent[idx]);
                idx++;

                setTimeout(streamChar, delay);
            }

            streamChar();
        }

        // Update choke display in ARACHNID footer
        function updateChokeDisplay(value) {
            arachnid.lastChokeValue = value;
            document.getElementById('disp-choke').textContent = `${Math.round(value * 100)}%`;
        }

        // ================================================================

        // Send legacy JSON commands (for buttons that still use it)
        function sendCommand(cmd) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ command: cmd }));
                logEvent('CMD', `Sent: ${cmd}`);
            } else {
                logEvent('ALERT', 'Cannot send - not connected');
            }
        }

        // Initialize
        logEvent('SYSTEM', 'NEON//SYSTOLE v1.0 initializing...');
        logEvent('SYSTEM', 'BIO-S/1.0 protocol ready (downstream)');
        logEvent('SYSTEM', 'BIO-C/1.0 protocol ready (upstream)');
        logEvent('ARACHNID', 'Hypertext Harvester ONLINE');
        render();
        connect();
        setupTactileControls();
        updateBookmarkDisplay(0);  // Initialize bookmark display
        updateModeBadges();

        // Demo mode - simulate data when not connected
        setInterval(() => {
            if (!state.connected) {
                state.targetCpu = 20 + Math.random() * 30;
                state.targetMem = 40 + Math.random() * 20;
                state.targetPpsRx = Math.floor(100 + Math.random() * 500);
                state.targetPpsTx = Math.floor(50 + Math.random() * 200);
                state.uptime += 1000;
            }
        }, 1000);
    </script>
</body>
</html>
