# Decisions Log - 20251228_171652

This file captures major architectural and cryptographic choices for future reference.

## Target Architecture and Dev Path

- Target: AArch64 on QEMU "virt" (generic), UEFI-compatible boot flow.
- Rationale: Portable to custom boards, avoids Raspberry Pi-specific hardware quirks.
- Implication: Keep drivers minimal (UART) and rely on device tree for early boot.

## LLM Target

- Model family: Phi-2 (or equivalent small LLM).
- Execution model: LLM control muscle + sealed weight pages + organelle execution.
- Rationale: Keeps the "small muscle" constraint while enabling real inference.

## Blob Crypto Choice (Current Path)

- AEAD: ChaCha20-Poly1305 (stable dependencies in workspace today).
- Nonce field: 24 bytes stored in blob; first 12 bytes used for AEAD nonce.
- KDF: BLAKE3 keyed hash using header + full 24-byte nonce.
- Rationale: Avoids dependency conflicts; preserves fixed blob layout and
  future-proofing for XChaCha by keeping a 24-byte nonce field.

## Code Size Budget (Contract Impact)

- Manifest is 256 bytes inside the 8192-byte payload.
- Maximum code/data region is 7936 bytes.
- Nucleus codegen and compiler checks are aligned to this budget.

## XChaCha Plan (Deferred)

- XChaCha20-Poly1305 is desired long-term.
- Deferred because workspace dependency resolution conflicts (zeroize + getrandom).
- Upgrade path: Replace AEAD type and nonce handling while keeping the
  same blob layout and nonce field size.

## Contract Spec

- Blob size fixed at 8256 bytes, payload 8192 bytes, manifest 256 bytes.
- Header (24 bytes) used as AEAD AAD.
- Capability bitmap enforced at load time.

References:
- `Ea_OS/docs/muscle-contract-v6.md`
- `Ea_OS/muscle-contract/src/lib.rs`

## Open Questions / Things to Test

- Nonce uniqueness enforcement: ensure production paths never reuse the 24-byte nonce field.
- AEAD boundary correctness: confirm AAD is exactly the 24-byte header and matches in all loaders.
- Endianness: verify header/manifest parsing on real AArch64 hardware matches the spec.
- Code hash coverage: validate that only the code region (manifest.code_size) is hashed.
- Capability enforcement: ensure kernel caps never exceed manifest bitmap and are denied by default.
- Update and IO budgets: confirm these are enforced at runtime and reflected in scheduling.
- Deterministic mode: ensure it is compile-time gated for tests only and never used in production.
- getrandom patch: confirm compatibility with rand_core error handling across toolchains.
- Boot target: validate QEMU virt + UEFI path before any Raspberry Pi or board-specific work.
- Preloader constraints: confirm size limits and handoff mechanism in the chosen boot path.
- LLM weight storage: define how weights are paged, sealed, and verified (lattice vs disk).
- LLM memory budget: confirm KV-cache limits and page accounting against the muscle budget.
- Organelle boundary: test that LLM organelles cannot exceed declared capabilities.
- Quantization format: decide GGUF vs custom and validate deterministic output across runs.
- Model integrity: verify weights_root and per-page hashes against a fixed root.
- Telemetry privacy: ensure audit logs don't leak prompt or PHI content.
- Capability upgrades: ensure muscle version upgrades cannot expand caps without explicit policy.
- Attestation binding: test that boot attestation ties to the exact kernel and contract version.
- Ledger integration: confirm update emission is capability-gated and rate-limited.
